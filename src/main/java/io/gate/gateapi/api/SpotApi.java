/*
 * Gate API v4
 * Welcome to Gate.io API  APIv4 provides spot, margin and futures trading operations. There are public APIs to retrieve the real-time market statistics, and private APIs which needs authentication to trade on user's behalf.
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package io.gate.gateapi.api;

import io.gate.gateapi.ApiCallback;
import io.gate.gateapi.ApiClient;
import io.gate.gateapi.ApiException;
import io.gate.gateapi.ApiResponse;
import io.gate.gateapi.Configuration;
import io.gate.gateapi.Pair;

import com.google.gson.reflect.TypeToken;


import io.gate.gateapi.models.BatchAmendItem;
import io.gate.gateapi.models.BatchOrder;
import io.gate.gateapi.models.CancelBatchOrder;
import io.gate.gateapi.models.CancelOrderResult;
import io.gate.gateapi.models.CountdownCancelAllSpotTask;
import io.gate.gateapi.models.Currency;
import io.gate.gateapi.models.CurrencyPair;
import io.gate.gateapi.models.LiquidateOrder;
import io.gate.gateapi.models.OpenOrders;
import io.gate.gateapi.models.Order;
import io.gate.gateapi.models.OrderBook;
import io.gate.gateapi.models.OrderCancel;
import io.gate.gateapi.models.OrderPatch;
import io.gate.gateapi.models.SpotAccount;
import io.gate.gateapi.models.SpotAccountBook;
import io.gate.gateapi.models.SpotFee;
import io.gate.gateapi.models.SpotInsuranceHistory;
import io.gate.gateapi.models.SpotPriceTriggeredOrder;
import io.gate.gateapi.models.SystemTime;
import io.gate.gateapi.models.Ticker;
import io.gate.gateapi.models.Trade;
import io.gate.gateapi.models.TriggerOrderResponse;
import io.gate.gateapi.models.TriggerTime;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class SpotApi {
    private ApiClient localVarApiClient;

    public SpotApi() {
        this(Configuration.getDefaultApiClient());
    }

    public SpotApi(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    /**
     * Build call for listCurrencies
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> List retrieved </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call listCurrenciesCall(final ApiCallback _callback) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/spot/currencies";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();
        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call listCurrenciesValidateBeforeCall(final ApiCallback _callback) throws ApiException {
        okhttp3.Call localVarCall = listCurrenciesCall(_callback);
        return localVarCall;
    }

    /**
     * List all currencies&#39; details
     * When a currency corresponds to multiple chains, you can query the information of multiple chains through the &#x60;chains&#x60; field, such as the charging and recharge status, identification, etc. of the chain.
     * @return List&lt;Currency&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> List retrieved </td><td>  -  </td></tr>
     </table>
     */
    public List<Currency> listCurrencies() throws ApiException {
        ApiResponse<List<Currency>> localVarResp = listCurrenciesWithHttpInfo();
        return localVarResp.getData();
    }

    /**
     * List all currencies&#39; details
     * When a currency corresponds to multiple chains, you can query the information of multiple chains through the &#x60;chains&#x60; field, such as the charging and recharge status, identification, etc. of the chain.
     * @return ApiResponse&lt;List&lt;Currency&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> List retrieved </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<List<Currency>> listCurrenciesWithHttpInfo() throws ApiException {
        okhttp3.Call localVarCall = listCurrenciesValidateBeforeCall(null);
        Type localVarReturnType = new TypeToken<List<Currency>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * List all currencies&#39; details (asynchronously)
     * When a currency corresponds to multiple chains, you can query the information of multiple chains through the &#x60;chains&#x60; field, such as the charging and recharge status, identification, etc. of the chain.
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> List retrieved </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call listCurrenciesAsync(final ApiCallback<List<Currency>> _callback) throws ApiException {
        okhttp3.Call localVarCall = listCurrenciesValidateBeforeCall(_callback);
        Type localVarReturnType = new TypeToken<List<Currency>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    /**
     * Build call for getCurrency
     * @param currency Currency name (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successfully retrieved </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getCurrencyCall(String currency, final ApiCallback _callback) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/spot/currencies/{currency}"
            .replaceAll("\\{" + "currency" + "\\}", localVarApiClient.escapeString(currency));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();
        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getCurrencyValidateBeforeCall(String currency, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'currency' is set
        if (currency == null) {
            throw new ApiException("Missing the required parameter 'currency' when calling getCurrency(Async)");
        }

        okhttp3.Call localVarCall = getCurrencyCall(currency, _callback);
        return localVarCall;
    }

    /**
     * Get details of a specific currency
     * 
     * @param currency Currency name (required)
     * @return Currency
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successfully retrieved </td><td>  -  </td></tr>
     </table>
     */
    public Currency getCurrency(String currency) throws ApiException {
        ApiResponse<Currency> localVarResp = getCurrencyWithHttpInfo(currency);
        return localVarResp.getData();
    }

    /**
     * Get details of a specific currency
     * 
     * @param currency Currency name (required)
     * @return ApiResponse&lt;Currency&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successfully retrieved </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Currency> getCurrencyWithHttpInfo(String currency) throws ApiException {
        okhttp3.Call localVarCall = getCurrencyValidateBeforeCall(currency, null);
        Type localVarReturnType = new TypeToken<Currency>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get details of a specific currency (asynchronously)
     * 
     * @param currency Currency name (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successfully retrieved </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getCurrencyAsync(String currency, final ApiCallback<Currency> _callback) throws ApiException {
        okhttp3.Call localVarCall = getCurrencyValidateBeforeCall(currency, _callback);
        Type localVarReturnType = new TypeToken<Currency>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    /**
     * Build call for listCurrencyPairs
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> All currency pairs retrieved </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call listCurrencyPairsCall(final ApiCallback _callback) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/spot/currency_pairs";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();
        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call listCurrencyPairsValidateBeforeCall(final ApiCallback _callback) throws ApiException {
        okhttp3.Call localVarCall = listCurrencyPairsCall(_callback);
        return localVarCall;
    }

    /**
     * List all currency pairs supported
     * 
     * @return List&lt;CurrencyPair&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> All currency pairs retrieved </td><td>  -  </td></tr>
     </table>
     */
    public List<CurrencyPair> listCurrencyPairs() throws ApiException {
        ApiResponse<List<CurrencyPair>> localVarResp = listCurrencyPairsWithHttpInfo();
        return localVarResp.getData();
    }

    /**
     * List all currency pairs supported
     * 
     * @return ApiResponse&lt;List&lt;CurrencyPair&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> All currency pairs retrieved </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<List<CurrencyPair>> listCurrencyPairsWithHttpInfo() throws ApiException {
        okhttp3.Call localVarCall = listCurrencyPairsValidateBeforeCall(null);
        Type localVarReturnType = new TypeToken<List<CurrencyPair>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * List all currency pairs supported (asynchronously)
     * 
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> All currency pairs retrieved </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call listCurrencyPairsAsync(final ApiCallback<List<CurrencyPair>> _callback) throws ApiException {
        okhttp3.Call localVarCall = listCurrencyPairsValidateBeforeCall(_callback);
        Type localVarReturnType = new TypeToken<List<CurrencyPair>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    /**
     * Build call for getCurrencyPair
     * @param currencyPair Currency pair (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successfully retrieved </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getCurrencyPairCall(String currencyPair, final ApiCallback _callback) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/spot/currency_pairs/{currency_pair}"
            .replaceAll("\\{" + "currency_pair" + "\\}", localVarApiClient.escapeString(currencyPair));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();
        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getCurrencyPairValidateBeforeCall(String currencyPair, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'currencyPair' is set
        if (currencyPair == null) {
            throw new ApiException("Missing the required parameter 'currencyPair' when calling getCurrencyPair(Async)");
        }

        okhttp3.Call localVarCall = getCurrencyPairCall(currencyPair, _callback);
        return localVarCall;
    }

    /**
     * Get details of a specifc currency pair
     * 
     * @param currencyPair Currency pair (required)
     * @return CurrencyPair
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successfully retrieved </td><td>  -  </td></tr>
     </table>
     */
    public CurrencyPair getCurrencyPair(String currencyPair) throws ApiException {
        ApiResponse<CurrencyPair> localVarResp = getCurrencyPairWithHttpInfo(currencyPair);
        return localVarResp.getData();
    }

    /**
     * Get details of a specifc currency pair
     * 
     * @param currencyPair Currency pair (required)
     * @return ApiResponse&lt;CurrencyPair&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successfully retrieved </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<CurrencyPair> getCurrencyPairWithHttpInfo(String currencyPair) throws ApiException {
        okhttp3.Call localVarCall = getCurrencyPairValidateBeforeCall(currencyPair, null);
        Type localVarReturnType = new TypeToken<CurrencyPair>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get details of a specifc currency pair (asynchronously)
     * 
     * @param currencyPair Currency pair (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successfully retrieved </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getCurrencyPairAsync(String currencyPair, final ApiCallback<CurrencyPair> _callback) throws ApiException {
        okhttp3.Call localVarCall = getCurrencyPairValidateBeforeCall(currencyPair, _callback);
        Type localVarReturnType = new TypeToken<CurrencyPair>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    private okhttp3.Call listTickersCall(String currencyPair, String timezone, final ApiCallback _callback) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/spot/tickers";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        if (currencyPair != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("currency_pair", currencyPair));
        }

        if (timezone != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("timezone", timezone));
        }

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();
        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call listTickersValidateBeforeCall(String currencyPair, String timezone, final ApiCallback _callback) throws ApiException {
        okhttp3.Call localVarCall = listTickersCall(currencyPair, timezone, _callback);
        return localVarCall;
    }


    private ApiResponse<List<Ticker>> listTickersWithHttpInfo(String currencyPair, String timezone) throws ApiException {
        okhttp3.Call localVarCall = listTickersValidateBeforeCall(currencyPair, timezone, null);
        Type localVarReturnType = new TypeToken<List<Ticker>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call listTickersAsync(String currencyPair, String timezone, final ApiCallback<List<Ticker>> _callback) throws ApiException {
        okhttp3.Call localVarCall = listTickersValidateBeforeCall(currencyPair, timezone, _callback);
        Type localVarReturnType = new TypeToken<List<Ticker>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class APIlistTickersRequest {
        private String currencyPair;
        private String timezone;

        private APIlistTickersRequest() {
        }

        /**
         * Set currencyPair
         * @param currencyPair Currency pair (optional)
         * @return APIlistTickersRequest
         */
        public APIlistTickersRequest currencyPair(String currencyPair) {
            this.currencyPair = currencyPair;
            return this;
        }

        /**
         * Set timezone
         * @param timezone Timezone (optional)
         * @return APIlistTickersRequest
         */
        public APIlistTickersRequest timezone(String timezone) {
            this.timezone = timezone;
            return this;
        }

        /**
         * Build call for listTickers
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successfully retrieved </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return listTickersCall(currencyPair, timezone, _callback);
        }

        /**
         * Execute listTickers request
         * @return List&lt;Ticker&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successfully retrieved </td><td>  -  </td></tr>
         </table>
         */
        public List<Ticker> execute() throws ApiException {
            ApiResponse<List<Ticker>> localVarResp = listTickersWithHttpInfo(currencyPair, timezone);
            return localVarResp.getData();
        }

        /**
         * Execute listTickers request with HTTP info returned
         * @return ApiResponse&lt;List&lt;Ticker&gt;&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successfully retrieved </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<List<Ticker>> executeWithHttpInfo() throws ApiException {
            return listTickersWithHttpInfo(currencyPair, timezone);
        }

        /**
         * Execute listTickers request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successfully retrieved </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<List<Ticker>> _callback) throws ApiException {
            return listTickersAsync(currencyPair, timezone, _callback);
        }
    }

    /**
     * Retrieve ticker information
     * Return only related data if &#x60;currency_pair&#x60; is specified; otherwise return all of them
     * @return APIlistTickersRequest
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successfully retrieved </td><td>  -  </td></tr>
     </table>
     */
    public APIlistTickersRequest listTickers() {
        return new APIlistTickersRequest();
    }

    private okhttp3.Call listOrderBookCall(String currencyPair, String interval, Integer limit, Boolean withId, final ApiCallback _callback) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/spot/order_book";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        if (currencyPair != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("currency_pair", currencyPair));
        }

        if (interval != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("interval", interval));
        }

        if (limit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("limit", limit));
        }

        if (withId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("with_id", withId));
        }

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();
        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call listOrderBookValidateBeforeCall(String currencyPair, String interval, Integer limit, Boolean withId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'currencyPair' is set
        if (currencyPair == null) {
            throw new ApiException("Missing the required parameter 'currencyPair' when calling listOrderBook(Async)");
        }

        okhttp3.Call localVarCall = listOrderBookCall(currencyPair, interval, limit, withId, _callback);
        return localVarCall;
    }


    private ApiResponse<OrderBook> listOrderBookWithHttpInfo(String currencyPair, String interval, Integer limit, Boolean withId) throws ApiException {
        okhttp3.Call localVarCall = listOrderBookValidateBeforeCall(currencyPair, interval, limit, withId, null);
        Type localVarReturnType = new TypeToken<OrderBook>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call listOrderBookAsync(String currencyPair, String interval, Integer limit, Boolean withId, final ApiCallback<OrderBook> _callback) throws ApiException {
        okhttp3.Call localVarCall = listOrderBookValidateBeforeCall(currencyPair, interval, limit, withId, _callback);
        Type localVarReturnType = new TypeToken<OrderBook>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class APIlistOrderBookRequest {
        private final String currencyPair;
        private String interval;
        private Integer limit;
        private Boolean withId;

        private APIlistOrderBookRequest(String currencyPair) {
            this.currencyPair = currencyPair;
        }

        /**
         * Set interval
         * @param interval Order depth. 0 means no aggregation is applied. default to 0 (optional, default to &quot;0&quot;)
         * @return APIlistOrderBookRequest
         */
        public APIlistOrderBookRequest interval(String interval) {
            this.interval = interval;
            return this;
        }

        /**
         * Set limit
         * @param limit Maximum number of order depth data in asks or bids (optional, default to 10)
         * @return APIlistOrderBookRequest
         */
        public APIlistOrderBookRequest limit(Integer limit) {
            this.limit = limit;
            return this;
        }

        /**
         * Set withId
         * @param withId Return order book ID (optional, default to false)
         * @return APIlistOrderBookRequest
         */
        public APIlistOrderBookRequest withId(Boolean withId) {
            this.withId = withId;
            return this;
        }

        /**
         * Build call for listOrderBook
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successfully retrieved </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return listOrderBookCall(currencyPair, interval, limit, withId, _callback);
        }

        /**
         * Execute listOrderBook request
         * @return OrderBook
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successfully retrieved </td><td>  -  </td></tr>
         </table>
         */
        public OrderBook execute() throws ApiException {
            ApiResponse<OrderBook> localVarResp = listOrderBookWithHttpInfo(currencyPair, interval, limit, withId);
            return localVarResp.getData();
        }

        /**
         * Execute listOrderBook request with HTTP info returned
         * @return ApiResponse&lt;OrderBook&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successfully retrieved </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<OrderBook> executeWithHttpInfo() throws ApiException {
            return listOrderBookWithHttpInfo(currencyPair, interval, limit, withId);
        }

        /**
         * Execute listOrderBook request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successfully retrieved </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<OrderBook> _callback) throws ApiException {
            return listOrderBookAsync(currencyPair, interval, limit, withId, _callback);
        }
    }

    /**
     * Retrieve order book
     * Order book will be sorted by price from high to low on bids; low to high on asks
     * @param currencyPair Currency pair (required)
     * @return APIlistOrderBookRequest
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successfully retrieved </td><td>  -  </td></tr>
     </table>
     */
    public APIlistOrderBookRequest listOrderBook(String currencyPair) {
        return new APIlistOrderBookRequest(currencyPair);
    }

    private okhttp3.Call listTradesCall(String currencyPair, Integer limit, String lastId, Boolean reverse, Long from, Long to, Integer page, final ApiCallback _callback) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/spot/trades";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        if (currencyPair != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("currency_pair", currencyPair));
        }

        if (limit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("limit", limit));
        }

        if (lastId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("last_id", lastId));
        }

        if (reverse != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("reverse", reverse));
        }

        if (from != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("from", from));
        }

        if (to != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("to", to));
        }

        if (page != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("page", page));
        }

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();
        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call listTradesValidateBeforeCall(String currencyPair, Integer limit, String lastId, Boolean reverse, Long from, Long to, Integer page, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'currencyPair' is set
        if (currencyPair == null) {
            throw new ApiException("Missing the required parameter 'currencyPair' when calling listTrades(Async)");
        }

        okhttp3.Call localVarCall = listTradesCall(currencyPair, limit, lastId, reverse, from, to, page, _callback);
        return localVarCall;
    }


    private ApiResponse<List<Trade>> listTradesWithHttpInfo(String currencyPair, Integer limit, String lastId, Boolean reverse, Long from, Long to, Integer page) throws ApiException {
        okhttp3.Call localVarCall = listTradesValidateBeforeCall(currencyPair, limit, lastId, reverse, from, to, page, null);
        Type localVarReturnType = new TypeToken<List<Trade>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call listTradesAsync(String currencyPair, Integer limit, String lastId, Boolean reverse, Long from, Long to, Integer page, final ApiCallback<List<Trade>> _callback) throws ApiException {
        okhttp3.Call localVarCall = listTradesValidateBeforeCall(currencyPair, limit, lastId, reverse, from, to, page, _callback);
        Type localVarReturnType = new TypeToken<List<Trade>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class APIlistTradesRequest {
        private final String currencyPair;
        private Integer limit;
        private String lastId;
        private Boolean reverse;
        private Long from;
        private Long to;
        private Integer page;

        private APIlistTradesRequest(String currencyPair) {
            this.currencyPair = currencyPair;
        }

        /**
         * Set limit
         * @param limit Maximum number of records to be returned in a single list.  Default: 100, Minimum: 1, Maximum: 1000 (optional, default to 100)
         * @return APIlistTradesRequest
         */
        public APIlistTradesRequest limit(Integer limit) {
            this.limit = limit;
            return this;
        }

        /**
         * Set lastId
         * @param lastId Specify list staring point using the &#x60;id&#x60; of last record in previous list-query results (optional)
         * @return APIlistTradesRequest
         */
        public APIlistTradesRequest lastId(String lastId) {
            this.lastId = lastId;
            return this;
        }

        /**
         * Set reverse
         * @param reverse Whether the id of records to be retrieved should be less than the last_id specified. Default to false.  When &#x60;last_id&#x60; is specified. Set &#x60;reverse&#x60; to &#x60;true&#x60; to trace back trading history; &#x60;false&#x60; to retrieve latest tradings.  No effect if &#x60;last_id&#x60; is not specified. (optional, default to false)
         * @return APIlistTradesRequest
         */
        public APIlistTradesRequest reverse(Boolean reverse) {
            this.reverse = reverse;
            return this;
        }

        /**
         * Set from
         * @param from Start timestamp of the query (optional)
         * @return APIlistTradesRequest
         */
        public APIlistTradesRequest from(Long from) {
            this.from = from;
            return this;
        }

        /**
         * Set to
         * @param to Time range ending, default to current time (optional)
         * @return APIlistTradesRequest
         */
        public APIlistTradesRequest to(Long to) {
            this.to = to;
            return this;
        }

        /**
         * Set page
         * @param page Page number (optional, default to 1)
         * @return APIlistTradesRequest
         */
        public APIlistTradesRequest page(Integer page) {
            this.page = page;
            return this;
        }

        /**
         * Build call for listTrades
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> List retrieved </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return listTradesCall(currencyPair, limit, lastId, reverse, from, to, page, _callback);
        }

        /**
         * Execute listTrades request
         * @return List&lt;Trade&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> List retrieved </td><td>  -  </td></tr>
         </table>
         */
        public List<Trade> execute() throws ApiException {
            ApiResponse<List<Trade>> localVarResp = listTradesWithHttpInfo(currencyPair, limit, lastId, reverse, from, to, page);
            return localVarResp.getData();
        }

        /**
         * Execute listTrades request with HTTP info returned
         * @return ApiResponse&lt;List&lt;Trade&gt;&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> List retrieved </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<List<Trade>> executeWithHttpInfo() throws ApiException {
            return listTradesWithHttpInfo(currencyPair, limit, lastId, reverse, from, to, page);
        }

        /**
         * Execute listTrades request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> List retrieved </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<List<Trade>> _callback) throws ApiException {
            return listTradesAsync(currencyPair, limit, lastId, reverse, from, to, page, _callback);
        }
    }

    /**
     * Retrieve market trades
     * Supports &#x60;from&#x60; and &#x60;to&#x60; by time range query or page-turn query based on &#x60;last_id&#x60;. By default, query by time range is the last 30 days.  The query method based on &#x60;last_id&#x60; page turn is no longer recommended. If &#x60;last_id&#x60; is specified, the time range query parameters will be ignored.  The maximum number of pages when searching data using limit&amp;page paging function is 100,000, that is, limit * (page - 1) &lt;&#x3D; 100,000.
     * @param currencyPair Currency pair (required)
     * @return APIlistTradesRequest
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> List retrieved </td><td>  -  </td></tr>
     </table>
     */
    public APIlistTradesRequest listTrades(String currencyPair) {
        return new APIlistTradesRequest(currencyPair);
    }

    private okhttp3.Call listCandlesticksCall(String currencyPair, Integer limit, Long from, Long to, String interval, final ApiCallback _callback) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/spot/candlesticks";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        if (currencyPair != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("currency_pair", currencyPair));
        }

        if (limit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("limit", limit));
        }

        if (from != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("from", from));
        }

        if (to != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("to", to));
        }

        if (interval != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("interval", interval));
        }

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();
        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call listCandlesticksValidateBeforeCall(String currencyPair, Integer limit, Long from, Long to, String interval, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'currencyPair' is set
        if (currencyPair == null) {
            throw new ApiException("Missing the required parameter 'currencyPair' when calling listCandlesticks(Async)");
        }

        okhttp3.Call localVarCall = listCandlesticksCall(currencyPair, limit, from, to, interval, _callback);
        return localVarCall;
    }


    private ApiResponse<List<List<String>>> listCandlesticksWithHttpInfo(String currencyPair, Integer limit, Long from, Long to, String interval) throws ApiException {
        okhttp3.Call localVarCall = listCandlesticksValidateBeforeCall(currencyPair, limit, from, to, interval, null);
        Type localVarReturnType = new TypeToken<List<List<String>>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call listCandlesticksAsync(String currencyPair, Integer limit, Long from, Long to, String interval, final ApiCallback<List<List<String>>> _callback) throws ApiException {
        okhttp3.Call localVarCall = listCandlesticksValidateBeforeCall(currencyPair, limit, from, to, interval, _callback);
        Type localVarReturnType = new TypeToken<List<List<String>>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class APIlistCandlesticksRequest {
        private final String currencyPair;
        private Integer limit;
        private Long from;
        private Long to;
        private String interval;

        private APIlistCandlesticksRequest(String currencyPair) {
            this.currencyPair = currencyPair;
        }

        /**
         * Set limit
         * @param limit Maximum recent data points to return. &#x60;limit&#x60; is conflicted with &#x60;from&#x60; and &#x60;to&#x60;. If either &#x60;from&#x60; or &#x60;to&#x60; is specified, request will be rejected. (optional, default to 100)
         * @return APIlistCandlesticksRequest
         */
        public APIlistCandlesticksRequest limit(Integer limit) {
            this.limit = limit;
            return this;
        }

        /**
         * Set from
         * @param from Start time of candlesticks, formatted in Unix timestamp in seconds. Default to&#x60;to - 100 * interval&#x60; if not specified (optional)
         * @return APIlistCandlesticksRequest
         */
        public APIlistCandlesticksRequest from(Long from) {
            this.from = from;
            return this;
        }

        /**
         * Set to
         * @param to End time of candlesticks, formatted in Unix timestamp in seconds. Default to current time (optional)
         * @return APIlistCandlesticksRequest
         */
        public APIlistCandlesticksRequest to(Long to) {
            this.to = to;
            return this;
        }

        /**
         * Set interval
         * @param interval Interval time between data points. Note that &#x60;30d&#x60; means 1 natual month, not 30 days (optional, default to 30m)
         * @return APIlistCandlesticksRequest
         */
        public APIlistCandlesticksRequest interval(String interval) {
            this.interval = interval;
            return this;
        }

        /**
         * Build call for listCandlesticks
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successfully retrieved </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return listCandlesticksCall(currencyPair, limit, from, to, interval, _callback);
        }

        /**
         * Execute listCandlesticks request
         * @return List&lt;List&lt;String&gt;&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successfully retrieved </td><td>  -  </td></tr>
         </table>
         */
        public List<List<String>> execute() throws ApiException {
            ApiResponse<List<List<String>>> localVarResp = listCandlesticksWithHttpInfo(currencyPair, limit, from, to, interval);
            return localVarResp.getData();
        }

        /**
         * Execute listCandlesticks request with HTTP info returned
         * @return ApiResponse&lt;List&lt;List&lt;String&gt;&gt;&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successfully retrieved </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<List<List<String>>> executeWithHttpInfo() throws ApiException {
            return listCandlesticksWithHttpInfo(currencyPair, limit, from, to, interval);
        }

        /**
         * Execute listCandlesticks request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successfully retrieved </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<List<List<String>>> _callback) throws ApiException {
            return listCandlesticksAsync(currencyPair, limit, from, to, interval, _callback);
        }
    }

    /**
     * Market candlesticks
     * Maximum of 1000 points can be returned in a query. Be sure not to exceed the limit when specifying from, to and interval
     * @param currencyPair Currency pair (required)
     * @return APIlistCandlesticksRequest
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successfully retrieved </td><td>  -  </td></tr>
     </table>
     */
    public APIlistCandlesticksRequest listCandlesticks(String currencyPair) {
        return new APIlistCandlesticksRequest(currencyPair);
    }

    private okhttp3.Call getFeeCall(String currencyPair, final ApiCallback _callback) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/spot/fee";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        if (currencyPair != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("currency_pair", currencyPair));
        }

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();
        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] { "apiv4" };
        return localVarApiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @Deprecated
    @SuppressWarnings("rawtypes")
    private okhttp3.Call getFeeValidateBeforeCall(String currencyPair, final ApiCallback _callback) throws ApiException {
        okhttp3.Call localVarCall = getFeeCall(currencyPair, _callback);
        return localVarCall;
    }


    private ApiResponse<SpotFee> getFeeWithHttpInfo(String currencyPair) throws ApiException {
        okhttp3.Call localVarCall = getFeeValidateBeforeCall(currencyPair, null);
        Type localVarReturnType = new TypeToken<SpotFee>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call getFeeAsync(String currencyPair, final ApiCallback<SpotFee> _callback) throws ApiException {
        okhttp3.Call localVarCall = getFeeValidateBeforeCall(currencyPair, _callback);
        Type localVarReturnType = new TypeToken<SpotFee>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class APIgetFeeRequest {
        private String currencyPair;

        private APIgetFeeRequest() {
        }

        /**
         * Set currencyPair
         * @param currencyPair Specify a currency pair to retrieve precise fee rate  This field is optional. In most cases, the fee rate is identical among all currency pairs (optional)
         * @return APIgetFeeRequest
         */
        public APIgetFeeRequest currencyPair(String currencyPair) {
            this.currencyPair = currencyPair;
            return this;
        }

        /**
         * Build call for getFee
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successfully retrieved </td><td>  -  </td></tr>
         </table>
         * @deprecated
         */
        @Deprecated
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return getFeeCall(currencyPair, _callback);
        }

        /**
         * Execute getFee request
         * @return SpotFee
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successfully retrieved </td><td>  -  </td></tr>
         </table>
         * @deprecated
         */
        @Deprecated
        public SpotFee execute() throws ApiException {
            ApiResponse<SpotFee> localVarResp = getFeeWithHttpInfo(currencyPair);
            return localVarResp.getData();
        }

        /**
         * Execute getFee request with HTTP info returned
         * @return ApiResponse&lt;SpotFee&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successfully retrieved </td><td>  -  </td></tr>
         </table>
         * @deprecated
         */
        @Deprecated
        public ApiResponse<SpotFee> executeWithHttpInfo() throws ApiException {
            return getFeeWithHttpInfo(currencyPair);
        }

        /**
         * Execute getFee request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successfully retrieved </td><td>  -  </td></tr>
         </table>
         * @deprecated
         */
        @Deprecated
        public okhttp3.Call executeAsync(final ApiCallback<SpotFee> _callback) throws ApiException {
            return getFeeAsync(currencyPair, _callback);
        }
    }

    /**
     * Query user trading fee rates
     * This API is deprecated in favour of new fee retrieving API &#x60;/wallet/fee&#x60;.
     * @return APIgetFeeRequest
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successfully retrieved </td><td>  -  </td></tr>
     </table>
     * @deprecated
     */
    @Deprecated
    public APIgetFeeRequest getFee() {
        return new APIgetFeeRequest();
    }

    /**
     * Build call for getBatchSpotFee
     * @param currencyPairs A request can only query up to 50 currency pairs (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successfully retrieved </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getBatchSpotFeeCall(String currencyPairs, final ApiCallback _callback) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/spot/batch_fee";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        if (currencyPairs != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("currency_pairs", currencyPairs));
        }

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();
        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] { "apiv4" };
        return localVarApiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getBatchSpotFeeValidateBeforeCall(String currencyPairs, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'currencyPairs' is set
        if (currencyPairs == null) {
            throw new ApiException("Missing the required parameter 'currencyPairs' when calling getBatchSpotFee(Async)");
        }

        okhttp3.Call localVarCall = getBatchSpotFeeCall(currencyPairs, _callback);
        return localVarCall;
    }

    /**
     * Query a batch of user trading fee rates
     * 
     * @param currencyPairs A request can only query up to 50 currency pairs (required)
     * @return Map&lt;String, SpotFee&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successfully retrieved </td><td>  -  </td></tr>
     </table>
     */
    public Map<String, SpotFee> getBatchSpotFee(String currencyPairs) throws ApiException {
        ApiResponse<Map<String, SpotFee>> localVarResp = getBatchSpotFeeWithHttpInfo(currencyPairs);
        return localVarResp.getData();
    }

    /**
     * Query a batch of user trading fee rates
     * 
     * @param currencyPairs A request can only query up to 50 currency pairs (required)
     * @return ApiResponse&lt;Map&lt;String, SpotFee&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successfully retrieved </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Map<String, SpotFee>> getBatchSpotFeeWithHttpInfo(String currencyPairs) throws ApiException {
        okhttp3.Call localVarCall = getBatchSpotFeeValidateBeforeCall(currencyPairs, null);
        Type localVarReturnType = new TypeToken<Map<String, SpotFee>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Query a batch of user trading fee rates (asynchronously)
     * 
     * @param currencyPairs A request can only query up to 50 currency pairs (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successfully retrieved </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getBatchSpotFeeAsync(String currencyPairs, final ApiCallback<Map<String, SpotFee>> _callback) throws ApiException {
        okhttp3.Call localVarCall = getBatchSpotFeeValidateBeforeCall(currencyPairs, _callback);
        Type localVarReturnType = new TypeToken<Map<String, SpotFee>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    private okhttp3.Call listSpotAccountsCall(String currency, final ApiCallback _callback) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/spot/accounts";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        if (currency != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("currency", currency));
        }

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();
        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] { "apiv4" };
        return localVarApiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call listSpotAccountsValidateBeforeCall(String currency, final ApiCallback _callback) throws ApiException {
        okhttp3.Call localVarCall = listSpotAccountsCall(currency, _callback);
        return localVarCall;
    }


    private ApiResponse<List<SpotAccount>> listSpotAccountsWithHttpInfo(String currency) throws ApiException {
        okhttp3.Call localVarCall = listSpotAccountsValidateBeforeCall(currency, null);
        Type localVarReturnType = new TypeToken<List<SpotAccount>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call listSpotAccountsAsync(String currency, final ApiCallback<List<SpotAccount>> _callback) throws ApiException {
        okhttp3.Call localVarCall = listSpotAccountsValidateBeforeCall(currency, _callback);
        Type localVarReturnType = new TypeToken<List<SpotAccount>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class APIlistSpotAccountsRequest {
        private String currency;

        private APIlistSpotAccountsRequest() {
        }

        /**
         * Set currency
         * @param currency Retrieve data of the specified currency (optional)
         * @return APIlistSpotAccountsRequest
         */
        public APIlistSpotAccountsRequest currency(String currency) {
            this.currency = currency;
            return this;
        }

        /**
         * Build call for listSpotAccounts
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> List retrieved </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return listSpotAccountsCall(currency, _callback);
        }

        /**
         * Execute listSpotAccounts request
         * @return List&lt;SpotAccount&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> List retrieved </td><td>  -  </td></tr>
         </table>
         */
        public List<SpotAccount> execute() throws ApiException {
            ApiResponse<List<SpotAccount>> localVarResp = listSpotAccountsWithHttpInfo(currency);
            return localVarResp.getData();
        }

        /**
         * Execute listSpotAccounts request with HTTP info returned
         * @return ApiResponse&lt;List&lt;SpotAccount&gt;&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> List retrieved </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<List<SpotAccount>> executeWithHttpInfo() throws ApiException {
            return listSpotAccountsWithHttpInfo(currency);
        }

        /**
         * Execute listSpotAccounts request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> List retrieved </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<List<SpotAccount>> _callback) throws ApiException {
            return listSpotAccountsAsync(currency, _callback);
        }
    }

    /**
     * List spot accounts
     * 
     * @return APIlistSpotAccountsRequest
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> List retrieved </td><td>  -  </td></tr>
     </table>
     */
    public APIlistSpotAccountsRequest listSpotAccounts() {
        return new APIlistSpotAccountsRequest();
    }

    private okhttp3.Call listSpotAccountBookCall(String currency, Long from, Long to, Integer page, Integer limit, String type, String code, final ApiCallback _callback) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/spot/account_book";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        if (currency != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("currency", currency));
        }

        if (from != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("from", from));
        }

        if (to != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("to", to));
        }

        if (page != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("page", page));
        }

        if (limit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("limit", limit));
        }

        if (type != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("type", type));
        }

        if (code != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("code", code));
        }

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();
        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] { "apiv4" };
        return localVarApiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call listSpotAccountBookValidateBeforeCall(String currency, Long from, Long to, Integer page, Integer limit, String type, String code, final ApiCallback _callback) throws ApiException {
        okhttp3.Call localVarCall = listSpotAccountBookCall(currency, from, to, page, limit, type, code, _callback);
        return localVarCall;
    }


    private ApiResponse<List<SpotAccountBook>> listSpotAccountBookWithHttpInfo(String currency, Long from, Long to, Integer page, Integer limit, String type, String code) throws ApiException {
        okhttp3.Call localVarCall = listSpotAccountBookValidateBeforeCall(currency, from, to, page, limit, type, code, null);
        Type localVarReturnType = new TypeToken<List<SpotAccountBook>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call listSpotAccountBookAsync(String currency, Long from, Long to, Integer page, Integer limit, String type, String code, final ApiCallback<List<SpotAccountBook>> _callback) throws ApiException {
        okhttp3.Call localVarCall = listSpotAccountBookValidateBeforeCall(currency, from, to, page, limit, type, code, _callback);
        Type localVarReturnType = new TypeToken<List<SpotAccountBook>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class APIlistSpotAccountBookRequest {
        private String currency;
        private Long from;
        private Long to;
        private Integer page;
        private Integer limit;
        private String type;
        private String code;

        private APIlistSpotAccountBookRequest() {
        }

        /**
         * Set currency
         * @param currency Retrieve data of the specified currency (optional)
         * @return APIlistSpotAccountBookRequest
         */
        public APIlistSpotAccountBookRequest currency(String currency) {
            this.currency = currency;
            return this;
        }

        /**
         * Set from
         * @param from Start timestamp of the query (optional)
         * @return APIlistSpotAccountBookRequest
         */
        public APIlistSpotAccountBookRequest from(Long from) {
            this.from = from;
            return this;
        }

        /**
         * Set to
         * @param to Time range ending, default to current time (optional)
         * @return APIlistSpotAccountBookRequest
         */
        public APIlistSpotAccountBookRequest to(Long to) {
            this.to = to;
            return this;
        }

        /**
         * Set page
         * @param page Page number (optional, default to 1)
         * @return APIlistSpotAccountBookRequest
         */
        public APIlistSpotAccountBookRequest page(Integer page) {
            this.page = page;
            return this;
        }

        /**
         * Set limit
         * @param limit Maximum number of records to be returned in a single list (optional, default to 100)
         * @return APIlistSpotAccountBookRequest
         */
        public APIlistSpotAccountBookRequest limit(Integer limit) {
            this.limit = limit;
            return this;
        }

        /**
         * Set type
         * @param type Only retrieve changes of the specified type. All types will be returned if not specified. (optional)
         * @return APIlistSpotAccountBookRequest
         */
        public APIlistSpotAccountBookRequest type(String type) {
            this.type = type;
            return this;
        }

        /**
         * Set code
         * @param code Specify account change code query, if not specified, all change types are included, and the priority is higher than &#x60;type&#x60; (optional)
         * @return APIlistSpotAccountBookRequest
         */
        public APIlistSpotAccountBookRequest code(String code) {
            this.code = code;
            return this;
        }

        /**
         * Build call for listSpotAccountBook
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> List retrieved </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return listSpotAccountBookCall(currency, from, to, page, limit, type, code, _callback);
        }

        /**
         * Execute listSpotAccountBook request
         * @return List&lt;SpotAccountBook&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> List retrieved </td><td>  -  </td></tr>
         </table>
         */
        public List<SpotAccountBook> execute() throws ApiException {
            ApiResponse<List<SpotAccountBook>> localVarResp = listSpotAccountBookWithHttpInfo(currency, from, to, page, limit, type, code);
            return localVarResp.getData();
        }

        /**
         * Execute listSpotAccountBook request with HTTP info returned
         * @return ApiResponse&lt;List&lt;SpotAccountBook&gt;&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> List retrieved </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<List<SpotAccountBook>> executeWithHttpInfo() throws ApiException {
            return listSpotAccountBookWithHttpInfo(currency, from, to, page, limit, type, code);
        }

        /**
         * Execute listSpotAccountBook request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> List retrieved </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<List<SpotAccountBook>> _callback) throws ApiException {
            return listSpotAccountBookAsync(currency, from, to, page, limit, type, code, _callback);
        }
    }

    /**
     * Query account book
     * Record query time range is not allowed to exceed 30 days.  The maximum number of pages when searching data using limit&amp;page paging function is 100,000, that is, limit * (page - 1) &lt;&#x3D; 100,000.
     * @return APIlistSpotAccountBookRequest
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> List retrieved </td><td>  -  </td></tr>
     </table>
     */
    public APIlistSpotAccountBookRequest listSpotAccountBook() {
        return new APIlistSpotAccountBookRequest();
    }

    /**
     * Build call for createBatchOrders
     * @param order  (required)
     * @param xGateExptime Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Request is completed </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call createBatchOrdersCall(List<Order> order, String xGateExptime, final ApiCallback _callback) throws ApiException {
        Object localVarPostBody = order;

        // create path and map variables
        String localVarPath = "/spot/batch_orders";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        if (xGateExptime != null) {
            localVarHeaderParams.put("x-gate-exptime", localVarApiClient.parameterToString(xGateExptime));
        }

        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();
        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] { "apiv4" };
        return localVarApiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call createBatchOrdersValidateBeforeCall(List<Order> order, String xGateExptime, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'order' is set
        if (order == null) {
            throw new ApiException("Missing the required parameter 'order' when calling createBatchOrders(Async)");
        }

        okhttp3.Call localVarCall = createBatchOrdersCall(order, xGateExptime, _callback);
        return localVarCall;
    }

    /**
     * Create a batch of orders
     * Batch orders requirements:  1. custom order field &#x60;text&#x60; is required 2. At most 4 currency pairs, maximum 10 orders each, are allowed in one request 3. No mixture of spot orders and margin orders, i.e. &#x60;account&#x60; must be identical for all orders 
     * @param order  (required)
     * @param xGateExptime Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)
     * @return List&lt;BatchOrder&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Request is completed </td><td>  -  </td></tr>
     </table>
     */
    public List<BatchOrder> createBatchOrders(List<Order> order, String xGateExptime) throws ApiException {
        ApiResponse<List<BatchOrder>> localVarResp = createBatchOrdersWithHttpInfo(order, xGateExptime);
        return localVarResp.getData();
    }

    /**
     * Create a batch of orders
     * Batch orders requirements:  1. custom order field &#x60;text&#x60; is required 2. At most 4 currency pairs, maximum 10 orders each, are allowed in one request 3. No mixture of spot orders and margin orders, i.e. &#x60;account&#x60; must be identical for all orders 
     * @param order  (required)
     * @param xGateExptime Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)
     * @return ApiResponse&lt;List&lt;BatchOrder&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Request is completed </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<List<BatchOrder>> createBatchOrdersWithHttpInfo(List<Order> order, String xGateExptime) throws ApiException {
        okhttp3.Call localVarCall = createBatchOrdersValidateBeforeCall(order, xGateExptime, null);
        Type localVarReturnType = new TypeToken<List<BatchOrder>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Create a batch of orders (asynchronously)
     * Batch orders requirements:  1. custom order field &#x60;text&#x60; is required 2. At most 4 currency pairs, maximum 10 orders each, are allowed in one request 3. No mixture of spot orders and margin orders, i.e. &#x60;account&#x60; must be identical for all orders 
     * @param order  (required)
     * @param xGateExptime Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Request is completed </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call createBatchOrdersAsync(List<Order> order, String xGateExptime, final ApiCallback<List<BatchOrder>> _callback) throws ApiException {
        okhttp3.Call localVarCall = createBatchOrdersValidateBeforeCall(order, xGateExptime, _callback);
        Type localVarReturnType = new TypeToken<List<BatchOrder>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    private okhttp3.Call listAllOpenOrdersCall(Integer page, Integer limit, String account, final ApiCallback _callback) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/spot/open_orders";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        if (page != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("page", page));
        }

        if (limit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("limit", limit));
        }

        if (account != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("account", account));
        }

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();
        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] { "apiv4" };
        return localVarApiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call listAllOpenOrdersValidateBeforeCall(Integer page, Integer limit, String account, final ApiCallback _callback) throws ApiException {
        okhttp3.Call localVarCall = listAllOpenOrdersCall(page, limit, account, _callback);
        return localVarCall;
    }


    private ApiResponse<List<OpenOrders>> listAllOpenOrdersWithHttpInfo(Integer page, Integer limit, String account) throws ApiException {
        okhttp3.Call localVarCall = listAllOpenOrdersValidateBeforeCall(page, limit, account, null);
        Type localVarReturnType = new TypeToken<List<OpenOrders>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call listAllOpenOrdersAsync(Integer page, Integer limit, String account, final ApiCallback<List<OpenOrders>> _callback) throws ApiException {
        okhttp3.Call localVarCall = listAllOpenOrdersValidateBeforeCall(page, limit, account, _callback);
        Type localVarReturnType = new TypeToken<List<OpenOrders>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class APIlistAllOpenOrdersRequest {
        private Integer page;
        private Integer limit;
        private String account;

        private APIlistAllOpenOrdersRequest() {
        }

        /**
         * Set page
         * @param page Page number (optional, default to 1)
         * @return APIlistAllOpenOrdersRequest
         */
        public APIlistAllOpenOrdersRequest page(Integer page) {
            this.page = page;
            return this;
        }

        /**
         * Set limit
         * @param limit Maximum number of records returned in one page in each currency pair (optional, default to 100)
         * @return APIlistAllOpenOrdersRequest
         */
        public APIlistAllOpenOrdersRequest limit(Integer limit) {
            this.limit = limit;
            return this;
        }

        /**
         * Set account
         * @param account Specify query account. (optional)
         * @return APIlistAllOpenOrdersRequest
         */
        public APIlistAllOpenOrdersRequest account(String account) {
            this.account = account;
            return this;
        }

        /**
         * Build call for listAllOpenOrders
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> List retrieved </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return listAllOpenOrdersCall(page, limit, account, _callback);
        }

        /**
         * Execute listAllOpenOrders request
         * @return List&lt;OpenOrders&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> List retrieved </td><td>  -  </td></tr>
         </table>
         */
        public List<OpenOrders> execute() throws ApiException {
            ApiResponse<List<OpenOrders>> localVarResp = listAllOpenOrdersWithHttpInfo(page, limit, account);
            return localVarResp.getData();
        }

        /**
         * Execute listAllOpenOrders request with HTTP info returned
         * @return ApiResponse&lt;List&lt;OpenOrders&gt;&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> List retrieved </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<List<OpenOrders>> executeWithHttpInfo() throws ApiException {
            return listAllOpenOrdersWithHttpInfo(page, limit, account);
        }

        /**
         * Execute listAllOpenOrders request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> List retrieved </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<List<OpenOrders>> _callback) throws ApiException {
            return listAllOpenOrdersAsync(page, limit, account, _callback);
        }
    }

    /**
     * List all open orders
     * Query the current order list of all trading pairs. Please note that the paging parameter controls the number of pending orders in each trading pair. There is no paging control for the number of trading pairs. All trading pairs with pending orders will be returned.
     * @return APIlistAllOpenOrdersRequest
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> List retrieved </td><td>  -  </td></tr>
     </table>
     */
    public APIlistAllOpenOrdersRequest listAllOpenOrders() {
        return new APIlistAllOpenOrdersRequest();
    }

    /**
     * Build call for createCrossLiquidateOrder
     * @param liquidateOrder  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> order created </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call createCrossLiquidateOrderCall(LiquidateOrder liquidateOrder, final ApiCallback _callback) throws ApiException {
        Object localVarPostBody = liquidateOrder;

        // create path and map variables
        String localVarPath = "/spot/cross_liquidate_orders";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();
        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] { "apiv4" };
        return localVarApiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call createCrossLiquidateOrderValidateBeforeCall(LiquidateOrder liquidateOrder, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'liquidateOrder' is set
        if (liquidateOrder == null) {
            throw new ApiException("Missing the required parameter 'liquidateOrder' when calling createCrossLiquidateOrder(Async)");
        }

        okhttp3.Call localVarCall = createCrossLiquidateOrderCall(liquidateOrder, _callback);
        return localVarCall;
    }

    /**
     * close position when cross-currency is disabled
     * Currently, only cross-margin accounts are supported to close position when cross currencies are disabled.  Maximum buy quantity &#x3D; (unpaid principal and interest - currency balance - the amount of the currency in the order book) / 0.998
     * @param liquidateOrder  (required)
     * @return Order
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> order created </td><td>  -  </td></tr>
     </table>
     */
    public Order createCrossLiquidateOrder(LiquidateOrder liquidateOrder) throws ApiException {
        ApiResponse<Order> localVarResp = createCrossLiquidateOrderWithHttpInfo(liquidateOrder);
        return localVarResp.getData();
    }

    /**
     * close position when cross-currency is disabled
     * Currently, only cross-margin accounts are supported to close position when cross currencies are disabled.  Maximum buy quantity &#x3D; (unpaid principal and interest - currency balance - the amount of the currency in the order book) / 0.998
     * @param liquidateOrder  (required)
     * @return ApiResponse&lt;Order&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> order created </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Order> createCrossLiquidateOrderWithHttpInfo(LiquidateOrder liquidateOrder) throws ApiException {
        okhttp3.Call localVarCall = createCrossLiquidateOrderValidateBeforeCall(liquidateOrder, null);
        Type localVarReturnType = new TypeToken<Order>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * close position when cross-currency is disabled (asynchronously)
     * Currently, only cross-margin accounts are supported to close position when cross currencies are disabled.  Maximum buy quantity &#x3D; (unpaid principal and interest - currency balance - the amount of the currency in the order book) / 0.998
     * @param liquidateOrder  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> order created </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call createCrossLiquidateOrderAsync(LiquidateOrder liquidateOrder, final ApiCallback<Order> _callback) throws ApiException {
        okhttp3.Call localVarCall = createCrossLiquidateOrderValidateBeforeCall(liquidateOrder, _callback);
        Type localVarReturnType = new TypeToken<Order>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    private okhttp3.Call listOrdersCall(String currencyPair, String status, Integer page, Integer limit, String account, Long from, Long to, String side, final ApiCallback _callback) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/spot/orders";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        if (currencyPair != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("currency_pair", currencyPair));
        }

        if (status != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("status", status));
        }

        if (page != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("page", page));
        }

        if (limit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("limit", limit));
        }

        if (account != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("account", account));
        }

        if (from != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("from", from));
        }

        if (to != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("to", to));
        }

        if (side != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("side", side));
        }

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();
        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] { "apiv4" };
        return localVarApiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call listOrdersValidateBeforeCall(String currencyPair, String status, Integer page, Integer limit, String account, Long from, Long to, String side, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'currencyPair' is set
        if (currencyPair == null) {
            throw new ApiException("Missing the required parameter 'currencyPair' when calling listOrders(Async)");
        }

        // verify the required parameter 'status' is set
        if (status == null) {
            throw new ApiException("Missing the required parameter 'status' when calling listOrders(Async)");
        }

        okhttp3.Call localVarCall = listOrdersCall(currencyPair, status, page, limit, account, from, to, side, _callback);
        return localVarCall;
    }


    private ApiResponse<List<Order>> listOrdersWithHttpInfo(String currencyPair, String status, Integer page, Integer limit, String account, Long from, Long to, String side) throws ApiException {
        okhttp3.Call localVarCall = listOrdersValidateBeforeCall(currencyPair, status, page, limit, account, from, to, side, null);
        Type localVarReturnType = new TypeToken<List<Order>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call listOrdersAsync(String currencyPair, String status, Integer page, Integer limit, String account, Long from, Long to, String side, final ApiCallback<List<Order>> _callback) throws ApiException {
        okhttp3.Call localVarCall = listOrdersValidateBeforeCall(currencyPair, status, page, limit, account, from, to, side, _callback);
        Type localVarReturnType = new TypeToken<List<Order>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class APIlistOrdersRequest {
        private final String currencyPair;
        private final String status;
        private Integer page;
        private Integer limit;
        private String account;
        private Long from;
        private Long to;
        private String side;

        private APIlistOrdersRequest(String currencyPair, String status) {
            this.currencyPair = currencyPair;
            this.status = status;
        }

        /**
         * Set page
         * @param page Page number (optional, default to 1)
         * @return APIlistOrdersRequest
         */
        public APIlistOrdersRequest page(Integer page) {
            this.page = page;
            return this;
        }

        /**
         * Set limit
         * @param limit Maximum number of records to be returned. If &#x60;status&#x60; is &#x60;open&#x60;, maximum of &#x60;limit&#x60; is 100 (optional, default to 100)
         * @return APIlistOrdersRequest
         */
        public APIlistOrdersRequest limit(Integer limit) {
            this.limit = limit;
            return this;
        }

        /**
         * Set account
         * @param account Specify query account. (optional)
         * @return APIlistOrdersRequest
         */
        public APIlistOrdersRequest account(String account) {
            this.account = account;
            return this;
        }

        /**
         * Set from
         * @param from Start timestamp of the query (optional)
         * @return APIlistOrdersRequest
         */
        public APIlistOrdersRequest from(Long from) {
            this.from = from;
            return this;
        }

        /**
         * Set to
         * @param to Time range ending, default to current time (optional)
         * @return APIlistOrdersRequest
         */
        public APIlistOrdersRequest to(Long to) {
            this.to = to;
            return this;
        }

        /**
         * Set side
         * @param side All bids or asks. Both included if not specified (optional)
         * @return APIlistOrdersRequest
         */
        public APIlistOrdersRequest side(String side) {
            this.side = side;
            return this;
        }

        /**
         * Build call for listOrders
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> List retrieved </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return listOrdersCall(currencyPair, status, page, limit, account, from, to, side, _callback);
        }

        /**
         * Execute listOrders request
         * @return List&lt;Order&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> List retrieved </td><td>  -  </td></tr>
         </table>
         */
        public List<Order> execute() throws ApiException {
            ApiResponse<List<Order>> localVarResp = listOrdersWithHttpInfo(currencyPair, status, page, limit, account, from, to, side);
            return localVarResp.getData();
        }

        /**
         * Execute listOrders request with HTTP info returned
         * @return ApiResponse&lt;List&lt;Order&gt;&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> List retrieved </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<List<Order>> executeWithHttpInfo() throws ApiException {
            return listOrdersWithHttpInfo(currencyPair, status, page, limit, account, from, to, side);
        }

        /**
         * Execute listOrders request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> List retrieved </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<List<Order>> _callback) throws ApiException {
            return listOrdersAsync(currencyPair, status, page, limit, account, from, to, side, _callback);
        }
    }

    /**
     * List orders
     * Note that the query results are spot order lists for spot, unified account and warehouse-by-site leverage accounts by default.  &#x60;status&#x60; is set to &#x60;open&#x60;, that is, when querying the pending order list, only pagination control of &#x60;page&#x60; and &#x60;limit&#x60; is supported. &#x60;limit&#x60; Maximum setting is only allowed to 100 . The &#x60;side&#x60; and &#x60;from&#x60;, &#x60;to&#x60; parameters for time range query are not supported.  &#x60;status&#x60; is set to &#x60;finished&#x60;, that is, when querying historical delegations, in addition to pagination queries, &#x60;from&#x60; and &#x60;to&#x60; are also supported by time range queries. In addition, it supports setting the &#x60;side&#x60; parameter to filter one-side history.  The parameters of the time range filtering are processed according to the order end time.
     * @param currencyPair Retrieve results with specified currency pair. It is required for open orders, but optional for finished ones. (required)
     * @param status List orders based on status  &#x60;open&#x60; - order is waiting to be filled &#x60;finished&#x60; - order has been filled or cancelled  (required)
     * @return APIlistOrdersRequest
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> List retrieved </td><td>  -  </td></tr>
     </table>
     */
    public APIlistOrdersRequest listOrders(String currencyPair, String status) {
        return new APIlistOrdersRequest(currencyPair, status);
    }

    /**
     * Build call for createOrder
     * @param order  (required)
     * @param xGateExptime Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> Order created. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call createOrderCall(Order order, String xGateExptime, final ApiCallback _callback) throws ApiException {
        Object localVarPostBody = order;

        // create path and map variables
        String localVarPath = "/spot/orders";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        if (xGateExptime != null) {
            localVarHeaderParams.put("x-gate-exptime", localVarApiClient.parameterToString(xGateExptime));
        }

        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();
        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] { "apiv4" };
        return localVarApiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call createOrderValidateBeforeCall(Order order, String xGateExptime, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'order' is set
        if (order == null) {
            throw new ApiException("Missing the required parameter 'order' when calling createOrder(Async)");
        }

        okhttp3.Call localVarCall = createOrderCall(order, xGateExptime, _callback);
        return localVarCall;
    }

    /**
     * Create an order
     * Support spot, margin, leverage, and full-position leverage orders. Use different accounts through the &#x60;account&#x60; field, default is &#x60;spot&#x60;, that is, use the spot account to place an order if the user is &#x60;unified&#x60; account, default is to place an order with a unified account  When using leveraged account trading, that is, when &#x60;account&#x60; is set to &#x60;margin&#x60;, you can set &#x60;auto_borrow&#x60; to &#x60;true&#x60;, In the case of insufficient account balance, the system will automatically execute the &#x60;POST /margin/uni/loans&#x60; to borrow the insufficient part. Whether the assets obtained after the leveraged order is automatically used to return the borrowing orders of the leveraged account in a position-by-store leverage account depends on the automatic repayment settings of the user&#39;s position-by-store leverage account**, The account automatic repayment settings can be queried and set through &#x60;/margin/auto_repay&#x60;.  Use unified account transactions, that is, when &#x60;account&#x60; is set to &#x60;unified&#x60;, &#x60;auto_borrow&#x60; \&quot; can also be enableTo realize the insufficient part of automatic borrowing, but unlike the leverage account, whether the entrustment of a unified account is automatically repayable depends on the   when placing an order&#x60;auto_repay&#x60; setting, this setting is only effective for the current entrustment, that is, only the assets obtained after the entrustment transaction will be used to repay the borrowing orders of the full-position leverage account. Unified account ordering currently supports &#x60;auto_borrow&#x60; and &#x60;auto_repay&#x60; at the same time.  Auto repayment will be triggered at the end of the order, i.e. &#x60;status&#x60; is &#x60;cancelled&#x60; or &#x60;closed&#x60; .  **Delegation Status**  The entrustment status in the pending order is &#x60;open&#x60;, which remains at &#x60;open&#x60; until all the quantity is traded. If it is eaten, the order ends and the status becomes &#x60;closed&#x60;. If the order is cancelled before all transactions are completed, regardless of whether there are partial transactions, the status will become &#x60;cancelled&#x60;  **Iceberg Entrustment**  &#x60;iceberg&#x60; is used to set the number of iceberg delegations displayed, and does not support complete hiding. Note that when hidden part of the transaction is charged according to the taker&#39;s handling rate.  **Restrict user transactions**  Set &#x60;stp_act&#x60; to decide to use strategies that limit user transactions
     * @param order  (required)
     * @param xGateExptime Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)
     * @return Order
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> Order created. </td><td>  -  </td></tr>
     </table>
     */
    public Order createOrder(Order order, String xGateExptime) throws ApiException {
        ApiResponse<Order> localVarResp = createOrderWithHttpInfo(order, xGateExptime);
        return localVarResp.getData();
    }

    /**
     * Create an order
     * Support spot, margin, leverage, and full-position leverage orders. Use different accounts through the &#x60;account&#x60; field, default is &#x60;spot&#x60;, that is, use the spot account to place an order if the user is &#x60;unified&#x60; account, default is to place an order with a unified account  When using leveraged account trading, that is, when &#x60;account&#x60; is set to &#x60;margin&#x60;, you can set &#x60;auto_borrow&#x60; to &#x60;true&#x60;, In the case of insufficient account balance, the system will automatically execute the &#x60;POST /margin/uni/loans&#x60; to borrow the insufficient part. Whether the assets obtained after the leveraged order is automatically used to return the borrowing orders of the leveraged account in a position-by-store leverage account depends on the automatic repayment settings of the user&#39;s position-by-store leverage account**, The account automatic repayment settings can be queried and set through &#x60;/margin/auto_repay&#x60;.  Use unified account transactions, that is, when &#x60;account&#x60; is set to &#x60;unified&#x60;, &#x60;auto_borrow&#x60; \&quot; can also be enableTo realize the insufficient part of automatic borrowing, but unlike the leverage account, whether the entrustment of a unified account is automatically repayable depends on the   when placing an order&#x60;auto_repay&#x60; setting, this setting is only effective for the current entrustment, that is, only the assets obtained after the entrustment transaction will be used to repay the borrowing orders of the full-position leverage account. Unified account ordering currently supports &#x60;auto_borrow&#x60; and &#x60;auto_repay&#x60; at the same time.  Auto repayment will be triggered at the end of the order, i.e. &#x60;status&#x60; is &#x60;cancelled&#x60; or &#x60;closed&#x60; .  **Delegation Status**  The entrustment status in the pending order is &#x60;open&#x60;, which remains at &#x60;open&#x60; until all the quantity is traded. If it is eaten, the order ends and the status becomes &#x60;closed&#x60;. If the order is cancelled before all transactions are completed, regardless of whether there are partial transactions, the status will become &#x60;cancelled&#x60;  **Iceberg Entrustment**  &#x60;iceberg&#x60; is used to set the number of iceberg delegations displayed, and does not support complete hiding. Note that when hidden part of the transaction is charged according to the taker&#39;s handling rate.  **Restrict user transactions**  Set &#x60;stp_act&#x60; to decide to use strategies that limit user transactions
     * @param order  (required)
     * @param xGateExptime Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)
     * @return ApiResponse&lt;Order&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> Order created. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Order> createOrderWithHttpInfo(Order order, String xGateExptime) throws ApiException {
        okhttp3.Call localVarCall = createOrderValidateBeforeCall(order, xGateExptime, null);
        Type localVarReturnType = new TypeToken<Order>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Create an order (asynchronously)
     * Support spot, margin, leverage, and full-position leverage orders. Use different accounts through the &#x60;account&#x60; field, default is &#x60;spot&#x60;, that is, use the spot account to place an order if the user is &#x60;unified&#x60; account, default is to place an order with a unified account  When using leveraged account trading, that is, when &#x60;account&#x60; is set to &#x60;margin&#x60;, you can set &#x60;auto_borrow&#x60; to &#x60;true&#x60;, In the case of insufficient account balance, the system will automatically execute the &#x60;POST /margin/uni/loans&#x60; to borrow the insufficient part. Whether the assets obtained after the leveraged order is automatically used to return the borrowing orders of the leveraged account in a position-by-store leverage account depends on the automatic repayment settings of the user&#39;s position-by-store leverage account**, The account automatic repayment settings can be queried and set through &#x60;/margin/auto_repay&#x60;.  Use unified account transactions, that is, when &#x60;account&#x60; is set to &#x60;unified&#x60;, &#x60;auto_borrow&#x60; \&quot; can also be enableTo realize the insufficient part of automatic borrowing, but unlike the leverage account, whether the entrustment of a unified account is automatically repayable depends on the   when placing an order&#x60;auto_repay&#x60; setting, this setting is only effective for the current entrustment, that is, only the assets obtained after the entrustment transaction will be used to repay the borrowing orders of the full-position leverage account. Unified account ordering currently supports &#x60;auto_borrow&#x60; and &#x60;auto_repay&#x60; at the same time.  Auto repayment will be triggered at the end of the order, i.e. &#x60;status&#x60; is &#x60;cancelled&#x60; or &#x60;closed&#x60; .  **Delegation Status**  The entrustment status in the pending order is &#x60;open&#x60;, which remains at &#x60;open&#x60; until all the quantity is traded. If it is eaten, the order ends and the status becomes &#x60;closed&#x60;. If the order is cancelled before all transactions are completed, regardless of whether there are partial transactions, the status will become &#x60;cancelled&#x60;  **Iceberg Entrustment**  &#x60;iceberg&#x60; is used to set the number of iceberg delegations displayed, and does not support complete hiding. Note that when hidden part of the transaction is charged according to the taker&#39;s handling rate.  **Restrict user transactions**  Set &#x60;stp_act&#x60; to decide to use strategies that limit user transactions
     * @param order  (required)
     * @param xGateExptime Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> Order created. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call createOrderAsync(Order order, String xGateExptime, final ApiCallback<Order> _callback) throws ApiException {
        okhttp3.Call localVarCall = createOrderValidateBeforeCall(order, xGateExptime, _callback);
        Type localVarReturnType = new TypeToken<Order>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    /**
     * Build call for cancelOrders
     * @param currencyPair Currency pair (optional)
     * @param side All bids or asks. Both included if not specified (optional)
     * @param account Specify Account Type  - Classic Account: If not specified, all include  - Unified Account: Specify &#x60;unified&#x60; (optional)
     * @param actionMode Processing Mode  When placing an order, different fields are returned based on the action_mode  - ACK: Asynchronous mode, returns only key order fields - RESULT: No clearing information - FULL: Full mode (default) (optional)
     * @param xGateExptime Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Batch cancellation request accepted. Query order status by listing orders </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call cancelOrdersCall(String currencyPair, String side, String account, String actionMode, String xGateExptime, final ApiCallback _callback) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/spot/orders";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        if (currencyPair != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("currency_pair", currencyPair));
        }

        if (side != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("side", side));
        }

        if (account != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("account", account));
        }

        if (actionMode != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("action_mode", actionMode));
        }

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        if (xGateExptime != null) {
            localVarHeaderParams.put("x-gate-exptime", localVarApiClient.parameterToString(xGateExptime));
        }

        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();
        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] { "apiv4" };
        return localVarApiClient.buildCall(localVarPath, "DELETE", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call cancelOrdersValidateBeforeCall(String currencyPair, String side, String account, String actionMode, String xGateExptime, final ApiCallback _callback) throws ApiException {
        okhttp3.Call localVarCall = cancelOrdersCall(currencyPair, side, account, actionMode, xGateExptime, _callback);
        return localVarCall;
    }

    /**
     * Cancel all &#x60;open&#x60; orders in specified currency pair
     * When the &#x60;account&#x60; parameter is not specified, all pending orders including spot, unified account, and position-by-position leverage will be cancelled. When &#x60;currency_pair&#x60; is not specified, all transaction pairs are revoked You can specify a certain account separately to cancel all orders under the specified account
     * @param currencyPair Currency pair (optional)
     * @param side All bids or asks. Both included if not specified (optional)
     * @param account Specify Account Type  - Classic Account: If not specified, all include  - Unified Account: Specify &#x60;unified&#x60; (optional)
     * @param actionMode Processing Mode  When placing an order, different fields are returned based on the action_mode  - ACK: Asynchronous mode, returns only key order fields - RESULT: No clearing information - FULL: Full mode (default) (optional)
     * @param xGateExptime Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)
     * @return List&lt;OrderCancel&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Batch cancellation request accepted. Query order status by listing orders </td><td>  -  </td></tr>
     </table>
     */
    public List<OrderCancel> cancelOrders(String currencyPair, String side, String account, String actionMode, String xGateExptime) throws ApiException {
        ApiResponse<List<OrderCancel>> localVarResp = cancelOrdersWithHttpInfo(currencyPair, side, account, actionMode, xGateExptime);
        return localVarResp.getData();
    }

    /**
     * Cancel all &#x60;open&#x60; orders in specified currency pair
     * When the &#x60;account&#x60; parameter is not specified, all pending orders including spot, unified account, and position-by-position leverage will be cancelled. When &#x60;currency_pair&#x60; is not specified, all transaction pairs are revoked You can specify a certain account separately to cancel all orders under the specified account
     * @param currencyPair Currency pair (optional)
     * @param side All bids or asks. Both included if not specified (optional)
     * @param account Specify Account Type  - Classic Account: If not specified, all include  - Unified Account: Specify &#x60;unified&#x60; (optional)
     * @param actionMode Processing Mode  When placing an order, different fields are returned based on the action_mode  - ACK: Asynchronous mode, returns only key order fields - RESULT: No clearing information - FULL: Full mode (default) (optional)
     * @param xGateExptime Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)
     * @return ApiResponse&lt;List&lt;OrderCancel&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Batch cancellation request accepted. Query order status by listing orders </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<List<OrderCancel>> cancelOrdersWithHttpInfo(String currencyPair, String side, String account, String actionMode, String xGateExptime) throws ApiException {
        okhttp3.Call localVarCall = cancelOrdersValidateBeforeCall(currencyPair, side, account, actionMode, xGateExptime, null);
        Type localVarReturnType = new TypeToken<List<OrderCancel>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Cancel all &#x60;open&#x60; orders in specified currency pair (asynchronously)
     * When the &#x60;account&#x60; parameter is not specified, all pending orders including spot, unified account, and position-by-position leverage will be cancelled. When &#x60;currency_pair&#x60; is not specified, all transaction pairs are revoked You can specify a certain account separately to cancel all orders under the specified account
     * @param currencyPair Currency pair (optional)
     * @param side All bids or asks. Both included if not specified (optional)
     * @param account Specify Account Type  - Classic Account: If not specified, all include  - Unified Account: Specify &#x60;unified&#x60; (optional)
     * @param actionMode Processing Mode  When placing an order, different fields are returned based on the action_mode  - ACK: Asynchronous mode, returns only key order fields - RESULT: No clearing information - FULL: Full mode (default) (optional)
     * @param xGateExptime Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Batch cancellation request accepted. Query order status by listing orders </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call cancelOrdersAsync(String currencyPair, String side, String account, String actionMode, String xGateExptime, final ApiCallback<List<OrderCancel>> _callback) throws ApiException {
        okhttp3.Call localVarCall = cancelOrdersValidateBeforeCall(currencyPair, side, account, actionMode, xGateExptime, _callback);
        Type localVarReturnType = new TypeToken<List<OrderCancel>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    /**
     * Build call for cancelBatchOrders
     * @param cancelBatchOrder  (required)
     * @param xGateExptime Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Batch cancellation completed </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call cancelBatchOrdersCall(List<CancelBatchOrder> cancelBatchOrder, String xGateExptime, final ApiCallback _callback) throws ApiException {
        Object localVarPostBody = cancelBatchOrder;

        // create path and map variables
        String localVarPath = "/spot/cancel_batch_orders";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        if (xGateExptime != null) {
            localVarHeaderParams.put("x-gate-exptime", localVarApiClient.parameterToString(xGateExptime));
        }

        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();
        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] { "apiv4" };
        return localVarApiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call cancelBatchOrdersValidateBeforeCall(List<CancelBatchOrder> cancelBatchOrder, String xGateExptime, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'cancelBatchOrder' is set
        if (cancelBatchOrder == null) {
            throw new ApiException("Missing the required parameter 'cancelBatchOrder' when calling cancelBatchOrders(Async)");
        }

        okhttp3.Call localVarCall = cancelBatchOrdersCall(cancelBatchOrder, xGateExptime, _callback);
        return localVarCall;
    }

    /**
     * Cancel a batch of orders with an ID list
     * Multiple currency pairs can be specified, but maximum 20 orders are allowed per request
     * @param cancelBatchOrder  (required)
     * @param xGateExptime Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)
     * @return List&lt;CancelOrderResult&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Batch cancellation completed </td><td>  -  </td></tr>
     </table>
     */
    public List<CancelOrderResult> cancelBatchOrders(List<CancelBatchOrder> cancelBatchOrder, String xGateExptime) throws ApiException {
        ApiResponse<List<CancelOrderResult>> localVarResp = cancelBatchOrdersWithHttpInfo(cancelBatchOrder, xGateExptime);
        return localVarResp.getData();
    }

    /**
     * Cancel a batch of orders with an ID list
     * Multiple currency pairs can be specified, but maximum 20 orders are allowed per request
     * @param cancelBatchOrder  (required)
     * @param xGateExptime Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)
     * @return ApiResponse&lt;List&lt;CancelOrderResult&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Batch cancellation completed </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<List<CancelOrderResult>> cancelBatchOrdersWithHttpInfo(List<CancelBatchOrder> cancelBatchOrder, String xGateExptime) throws ApiException {
        okhttp3.Call localVarCall = cancelBatchOrdersValidateBeforeCall(cancelBatchOrder, xGateExptime, null);
        Type localVarReturnType = new TypeToken<List<CancelOrderResult>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Cancel a batch of orders with an ID list (asynchronously)
     * Multiple currency pairs can be specified, but maximum 20 orders are allowed per request
     * @param cancelBatchOrder  (required)
     * @param xGateExptime Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Batch cancellation completed </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call cancelBatchOrdersAsync(List<CancelBatchOrder> cancelBatchOrder, String xGateExptime, final ApiCallback<List<CancelOrderResult>> _callback) throws ApiException {
        okhttp3.Call localVarCall = cancelBatchOrdersValidateBeforeCall(cancelBatchOrder, xGateExptime, _callback);
        Type localVarReturnType = new TypeToken<List<CancelOrderResult>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    /**
     * Build call for getOrder
     * @param orderId The order ID returned when the order was successfully created or the custom ID specified by the user&#39;s creation (i.e. the &#x60;text&#x60; field). Operations based on custom IDs can only be checked in pending orders. Only order ID can be used after the order is finished (transaction/cancel) (required)
     * @param currencyPair Specify the transaction pair to query. If you are querying pending order records, this field is required. If you are querying traded records, this field can be left blank. (required)
     * @param account Specify query account. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Detail retrieved </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getOrderCall(String orderId, String currencyPair, String account, final ApiCallback _callback) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/spot/orders/{order_id}"
            .replaceAll("\\{" + "order_id" + "\\}", localVarApiClient.escapeString(orderId));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        if (currencyPair != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("currency_pair", currencyPair));
        }

        if (account != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("account", account));
        }

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();
        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] { "apiv4" };
        return localVarApiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getOrderValidateBeforeCall(String orderId, String currencyPair, String account, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'orderId' is set
        if (orderId == null) {
            throw new ApiException("Missing the required parameter 'orderId' when calling getOrder(Async)");
        }

        // verify the required parameter 'currencyPair' is set
        if (currencyPair == null) {
            throw new ApiException("Missing the required parameter 'currencyPair' when calling getOrder(Async)");
        }

        okhttp3.Call localVarCall = getOrderCall(orderId, currencyPair, account, _callback);
        return localVarCall;
    }

    /**
     * Get a single order
     * By default, orders for spot, unified account and warehouse-by-site leverage account are checked.
     * @param orderId The order ID returned when the order was successfully created or the custom ID specified by the user&#39;s creation (i.e. the &#x60;text&#x60; field). Operations based on custom IDs can only be checked in pending orders. Only order ID can be used after the order is finished (transaction/cancel) (required)
     * @param currencyPair Specify the transaction pair to query. If you are querying pending order records, this field is required. If you are querying traded records, this field can be left blank. (required)
     * @param account Specify query account. (optional)
     * @return Order
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Detail retrieved </td><td>  -  </td></tr>
     </table>
     */
    public Order getOrder(String orderId, String currencyPair, String account) throws ApiException {
        ApiResponse<Order> localVarResp = getOrderWithHttpInfo(orderId, currencyPair, account);
        return localVarResp.getData();
    }

    /**
     * Get a single order
     * By default, orders for spot, unified account and warehouse-by-site leverage account are checked.
     * @param orderId The order ID returned when the order was successfully created or the custom ID specified by the user&#39;s creation (i.e. the &#x60;text&#x60; field). Operations based on custom IDs can only be checked in pending orders. Only order ID can be used after the order is finished (transaction/cancel) (required)
     * @param currencyPair Specify the transaction pair to query. If you are querying pending order records, this field is required. If you are querying traded records, this field can be left blank. (required)
     * @param account Specify query account. (optional)
     * @return ApiResponse&lt;Order&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Detail retrieved </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Order> getOrderWithHttpInfo(String orderId, String currencyPair, String account) throws ApiException {
        okhttp3.Call localVarCall = getOrderValidateBeforeCall(orderId, currencyPair, account, null);
        Type localVarReturnType = new TypeToken<Order>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get a single order (asynchronously)
     * By default, orders for spot, unified account and warehouse-by-site leverage account are checked.
     * @param orderId The order ID returned when the order was successfully created or the custom ID specified by the user&#39;s creation (i.e. the &#x60;text&#x60; field). Operations based on custom IDs can only be checked in pending orders. Only order ID can be used after the order is finished (transaction/cancel) (required)
     * @param currencyPair Specify the transaction pair to query. If you are querying pending order records, this field is required. If you are querying traded records, this field can be left blank. (required)
     * @param account Specify query account. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Detail retrieved </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getOrderAsync(String orderId, String currencyPair, String account, final ApiCallback<Order> _callback) throws ApiException {
        okhttp3.Call localVarCall = getOrderValidateBeforeCall(orderId, currencyPair, account, _callback);
        Type localVarReturnType = new TypeToken<Order>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    /**
     * Build call for cancelOrder
     * @param orderId The order ID returned when the order was successfully created or the custom ID specified by the user&#39;s creation (i.e. the &#x60;text&#x60; field). Operations based on custom IDs can only be checked in pending orders. Only order ID can be used after the order is finished (transaction/cancel) (required)
     * @param currencyPair Currency pair (required)
     * @param account Specify query account. (optional)
     * @param actionMode Processing Mode  When placing an order, different fields are returned based on the action_mode  - ACK: Asynchronous mode, returns only key order fields - RESULT: No clearing information - FULL: Full mode (default) (optional)
     * @param xGateExptime Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Order cancelled </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call cancelOrderCall(String orderId, String currencyPair, String account, String actionMode, String xGateExptime, final ApiCallback _callback) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/spot/orders/{order_id}"
            .replaceAll("\\{" + "order_id" + "\\}", localVarApiClient.escapeString(orderId));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        if (currencyPair != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("currency_pair", currencyPair));
        }

        if (account != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("account", account));
        }

        if (actionMode != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("action_mode", actionMode));
        }

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        if (xGateExptime != null) {
            localVarHeaderParams.put("x-gate-exptime", localVarApiClient.parameterToString(xGateExptime));
        }

        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();
        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] { "apiv4" };
        return localVarApiClient.buildCall(localVarPath, "DELETE", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call cancelOrderValidateBeforeCall(String orderId, String currencyPair, String account, String actionMode, String xGateExptime, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'orderId' is set
        if (orderId == null) {
            throw new ApiException("Missing the required parameter 'orderId' when calling cancelOrder(Async)");
        }

        // verify the required parameter 'currencyPair' is set
        if (currencyPair == null) {
            throw new ApiException("Missing the required parameter 'currencyPair' when calling cancelOrder(Async)");
        }

        okhttp3.Call localVarCall = cancelOrderCall(orderId, currencyPair, account, actionMode, xGateExptime, _callback);
        return localVarCall;
    }

    /**
     * Cancel a single order
     * By default, orders for spot, unified accounts and leveraged accounts are revoked.
     * @param orderId The order ID returned when the order was successfully created or the custom ID specified by the user&#39;s creation (i.e. the &#x60;text&#x60; field). Operations based on custom IDs can only be checked in pending orders. Only order ID can be used after the order is finished (transaction/cancel) (required)
     * @param currencyPair Currency pair (required)
     * @param account Specify query account. (optional)
     * @param actionMode Processing Mode  When placing an order, different fields are returned based on the action_mode  - ACK: Asynchronous mode, returns only key order fields - RESULT: No clearing information - FULL: Full mode (default) (optional)
     * @param xGateExptime Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)
     * @return Order
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Order cancelled </td><td>  -  </td></tr>
     </table>
     */
    public Order cancelOrder(String orderId, String currencyPair, String account, String actionMode, String xGateExptime) throws ApiException {
        ApiResponse<Order> localVarResp = cancelOrderWithHttpInfo(orderId, currencyPair, account, actionMode, xGateExptime);
        return localVarResp.getData();
    }

    /**
     * Cancel a single order
     * By default, orders for spot, unified accounts and leveraged accounts are revoked.
     * @param orderId The order ID returned when the order was successfully created or the custom ID specified by the user&#39;s creation (i.e. the &#x60;text&#x60; field). Operations based on custom IDs can only be checked in pending orders. Only order ID can be used after the order is finished (transaction/cancel) (required)
     * @param currencyPair Currency pair (required)
     * @param account Specify query account. (optional)
     * @param actionMode Processing Mode  When placing an order, different fields are returned based on the action_mode  - ACK: Asynchronous mode, returns only key order fields - RESULT: No clearing information - FULL: Full mode (default) (optional)
     * @param xGateExptime Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)
     * @return ApiResponse&lt;Order&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Order cancelled </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Order> cancelOrderWithHttpInfo(String orderId, String currencyPair, String account, String actionMode, String xGateExptime) throws ApiException {
        okhttp3.Call localVarCall = cancelOrderValidateBeforeCall(orderId, currencyPair, account, actionMode, xGateExptime, null);
        Type localVarReturnType = new TypeToken<Order>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Cancel a single order (asynchronously)
     * By default, orders for spot, unified accounts and leveraged accounts are revoked.
     * @param orderId The order ID returned when the order was successfully created or the custom ID specified by the user&#39;s creation (i.e. the &#x60;text&#x60; field). Operations based on custom IDs can only be checked in pending orders. Only order ID can be used after the order is finished (transaction/cancel) (required)
     * @param currencyPair Currency pair (required)
     * @param account Specify query account. (optional)
     * @param actionMode Processing Mode  When placing an order, different fields are returned based on the action_mode  - ACK: Asynchronous mode, returns only key order fields - RESULT: No clearing information - FULL: Full mode (default) (optional)
     * @param xGateExptime Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Order cancelled </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call cancelOrderAsync(String orderId, String currencyPair, String account, String actionMode, String xGateExptime, final ApiCallback<Order> _callback) throws ApiException {
        okhttp3.Call localVarCall = cancelOrderValidateBeforeCall(orderId, currencyPair, account, actionMode, xGateExptime, _callback);
        Type localVarReturnType = new TypeToken<Order>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    /**
     * Build call for amendOrder
     * @param orderId The order ID returned when the order was successfully created or the custom ID specified by the user&#39;s creation (i.e. the &#x60;text&#x60; field). Operations based on custom IDs can only be checked in pending orders. Only order ID can be used after the order is finished (transaction/cancel) (required)
     * @param orderPatch  (required)
     * @param currencyPair Currency pair (optional)
     * @param account Specify query account. (optional)
     * @param xGateExptime Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Updated </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call amendOrderCall(String orderId, OrderPatch orderPatch, String currencyPair, String account, String xGateExptime, final ApiCallback _callback) throws ApiException {
        Object localVarPostBody = orderPatch;

        // create path and map variables
        String localVarPath = "/spot/orders/{order_id}"
            .replaceAll("\\{" + "order_id" + "\\}", localVarApiClient.escapeString(orderId));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        if (currencyPair != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("currency_pair", currencyPair));
        }

        if (account != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("account", account));
        }

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        if (xGateExptime != null) {
            localVarHeaderParams.put("x-gate-exptime", localVarApiClient.parameterToString(xGateExptime));
        }

        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();
        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] { "apiv4" };
        return localVarApiClient.buildCall(localVarPath, "PATCH", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call amendOrderValidateBeforeCall(String orderId, OrderPatch orderPatch, String currencyPair, String account, String xGateExptime, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'orderId' is set
        if (orderId == null) {
            throw new ApiException("Missing the required parameter 'orderId' when calling amendOrder(Async)");
        }

        // verify the required parameter 'orderPatch' is set
        if (orderPatch == null) {
            throw new ApiException("Missing the required parameter 'orderPatch' when calling amendOrder(Async)");
        }

        okhttp3.Call localVarCall = amendOrderCall(orderId, orderPatch, currencyPair, account, xGateExptime, _callback);
        return localVarCall;
    }

    /**
     * Amend an order
     * By default modify orders for spot, unified account and leverage account.  At present, both the request body and query support currency_pair and account parameters, but the request body has higher priority  currency_pair must be filled in the request body or query   Currently, only the price or quantity modification (choose one of two)  About speed limit: Modify orders and create orders to share speed limit rules  About matching priority: Only modifying the quantity will become smaller and will not affect the priority of matching. If the price is modified or the quantity is modified, the priority will be adjusted to the end of the new price   Precautions: Modification quantity is less than the transaction quantity will trigger the order cancellation operation
     * @param orderId The order ID returned when the order was successfully created or the custom ID specified by the user&#39;s creation (i.e. the &#x60;text&#x60; field). Operations based on custom IDs can only be checked in pending orders. Only order ID can be used after the order is finished (transaction/cancel) (required)
     * @param orderPatch  (required)
     * @param currencyPair Currency pair (optional)
     * @param account Specify query account. (optional)
     * @param xGateExptime Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)
     * @return Order
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Updated </td><td>  -  </td></tr>
     </table>
     */
    public Order amendOrder(String orderId, OrderPatch orderPatch, String currencyPair, String account, String xGateExptime) throws ApiException {
        ApiResponse<Order> localVarResp = amendOrderWithHttpInfo(orderId, orderPatch, currencyPair, account, xGateExptime);
        return localVarResp.getData();
    }

    /**
     * Amend an order
     * By default modify orders for spot, unified account and leverage account.  At present, both the request body and query support currency_pair and account parameters, but the request body has higher priority  currency_pair must be filled in the request body or query   Currently, only the price or quantity modification (choose one of two)  About speed limit: Modify orders and create orders to share speed limit rules  About matching priority: Only modifying the quantity will become smaller and will not affect the priority of matching. If the price is modified or the quantity is modified, the priority will be adjusted to the end of the new price   Precautions: Modification quantity is less than the transaction quantity will trigger the order cancellation operation
     * @param orderId The order ID returned when the order was successfully created or the custom ID specified by the user&#39;s creation (i.e. the &#x60;text&#x60; field). Operations based on custom IDs can only be checked in pending orders. Only order ID can be used after the order is finished (transaction/cancel) (required)
     * @param orderPatch  (required)
     * @param currencyPair Currency pair (optional)
     * @param account Specify query account. (optional)
     * @param xGateExptime Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)
     * @return ApiResponse&lt;Order&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Updated </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Order> amendOrderWithHttpInfo(String orderId, OrderPatch orderPatch, String currencyPair, String account, String xGateExptime) throws ApiException {
        okhttp3.Call localVarCall = amendOrderValidateBeforeCall(orderId, orderPatch, currencyPair, account, xGateExptime, null);
        Type localVarReturnType = new TypeToken<Order>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Amend an order (asynchronously)
     * By default modify orders for spot, unified account and leverage account.  At present, both the request body and query support currency_pair and account parameters, but the request body has higher priority  currency_pair must be filled in the request body or query   Currently, only the price or quantity modification (choose one of two)  About speed limit: Modify orders and create orders to share speed limit rules  About matching priority: Only modifying the quantity will become smaller and will not affect the priority of matching. If the price is modified or the quantity is modified, the priority will be adjusted to the end of the new price   Precautions: Modification quantity is less than the transaction quantity will trigger the order cancellation operation
     * @param orderId The order ID returned when the order was successfully created or the custom ID specified by the user&#39;s creation (i.e. the &#x60;text&#x60; field). Operations based on custom IDs can only be checked in pending orders. Only order ID can be used after the order is finished (transaction/cancel) (required)
     * @param orderPatch  (required)
     * @param currencyPair Currency pair (optional)
     * @param account Specify query account. (optional)
     * @param xGateExptime Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Updated </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call amendOrderAsync(String orderId, OrderPatch orderPatch, String currencyPair, String account, String xGateExptime, final ApiCallback<Order> _callback) throws ApiException {
        okhttp3.Call localVarCall = amendOrderValidateBeforeCall(orderId, orderPatch, currencyPair, account, xGateExptime, _callback);
        Type localVarReturnType = new TypeToken<Order>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    private okhttp3.Call listMyTradesCall(String currencyPair, Integer limit, Integer page, String orderId, String account, Long from, Long to, final ApiCallback _callback) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/spot/my_trades";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        if (currencyPair != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("currency_pair", currencyPair));
        }

        if (limit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("limit", limit));
        }

        if (page != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("page", page));
        }

        if (orderId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("order_id", orderId));
        }

        if (account != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("account", account));
        }

        if (from != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("from", from));
        }

        if (to != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("to", to));
        }

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();
        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] { "apiv4" };
        return localVarApiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call listMyTradesValidateBeforeCall(String currencyPair, Integer limit, Integer page, String orderId, String account, Long from, Long to, final ApiCallback _callback) throws ApiException {
        okhttp3.Call localVarCall = listMyTradesCall(currencyPair, limit, page, orderId, account, from, to, _callback);
        return localVarCall;
    }


    private ApiResponse<List<Trade>> listMyTradesWithHttpInfo(String currencyPair, Integer limit, Integer page, String orderId, String account, Long from, Long to) throws ApiException {
        okhttp3.Call localVarCall = listMyTradesValidateBeforeCall(currencyPair, limit, page, orderId, account, from, to, null);
        Type localVarReturnType = new TypeToken<List<Trade>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call listMyTradesAsync(String currencyPair, Integer limit, Integer page, String orderId, String account, Long from, Long to, final ApiCallback<List<Trade>> _callback) throws ApiException {
        okhttp3.Call localVarCall = listMyTradesValidateBeforeCall(currencyPair, limit, page, orderId, account, from, to, _callback);
        Type localVarReturnType = new TypeToken<List<Trade>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class APIlistMyTradesRequest {
        private String currencyPair;
        private Integer limit;
        private Integer page;
        private String orderId;
        private String account;
        private Long from;
        private Long to;

        private APIlistMyTradesRequest() {
        }

        /**
         * Set currencyPair
         * @param currencyPair Retrieve results with specified currency pair (optional)
         * @return APIlistMyTradesRequest
         */
        public APIlistMyTradesRequest currencyPair(String currencyPair) {
            this.currencyPair = currencyPair;
            return this;
        }

        /**
         * Set limit
         * @param limit Maximum number of records to be returned in a single list.  Default: 100, Minimum: 1, Maximum: 1000 (optional, default to 100)
         * @return APIlistMyTradesRequest
         */
        public APIlistMyTradesRequest limit(Integer limit) {
            this.limit = limit;
            return this;
        }

        /**
         * Set page
         * @param page Page number (optional, default to 1)
         * @return APIlistMyTradesRequest
         */
        public APIlistMyTradesRequest page(Integer page) {
            this.page = page;
            return this;
        }

        /**
         * Set orderId
         * @param orderId Filter trades with specified order ID. &#x60;currency_pair&#x60; is also required if this field is present (optional)
         * @return APIlistMyTradesRequest
         */
        public APIlistMyTradesRequest orderId(String orderId) {
            this.orderId = orderId;
            return this;
        }

        /**
         * Set account
         * @param account Specify query account. (optional)
         * @return APIlistMyTradesRequest
         */
        public APIlistMyTradesRequest account(String account) {
            this.account = account;
            return this;
        }

        /**
         * Set from
         * @param from Start timestamp of the query (optional)
         * @return APIlistMyTradesRequest
         */
        public APIlistMyTradesRequest from(Long from) {
            this.from = from;
            return this;
        }

        /**
         * Set to
         * @param to Time range ending, default to current time (optional)
         * @return APIlistMyTradesRequest
         */
        public APIlistMyTradesRequest to(Long to) {
            this.to = to;
            return this;
        }

        /**
         * Build call for listMyTrades
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> List retrieved </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return listMyTradesCall(currencyPair, limit, page, orderId, account, from, to, _callback);
        }

        /**
         * Execute listMyTrades request
         * @return List&lt;Trade&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> List retrieved </td><td>  -  </td></tr>
         </table>
         */
        public List<Trade> execute() throws ApiException {
            ApiResponse<List<Trade>> localVarResp = listMyTradesWithHttpInfo(currencyPair, limit, page, orderId, account, from, to);
            return localVarResp.getData();
        }

        /**
         * Execute listMyTrades request with HTTP info returned
         * @return ApiResponse&lt;List&lt;Trade&gt;&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> List retrieved </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<List<Trade>> executeWithHttpInfo() throws ApiException {
            return listMyTradesWithHttpInfo(currencyPair, limit, page, orderId, account, from, to);
        }

        /**
         * Execute listMyTrades request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> List retrieved </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<List<Trade>> _callback) throws ApiException {
            return listMyTradesAsync(currencyPair, limit, page, orderId, account, from, to, _callback);
        }
    }

    /**
     * List personal trading history
     * By default query of transaction records for spot, unified account and warehouse-by-site leverage accounts.  The history within a specified time range can be queried by specifying &#x60;from&#x60; or (and) &#x60;to&#x60;.  - If no time parameters are specified, only data for the last 7 days can be obtained. - If only any parameter of &#x60;from&#x60; or &#x60;to&#x60; is specified, only 7-day data from the start (or end) of the specified time is returned. - The range of &#x60;from&#x60; and &#x60;to&#x60; is not allowed to exceed 30 days.  The parameters of the time range filter are processed according to the order end time.  The maximum number of pages when searching data using limit&amp;page paging function is 100,000, that is, limit * (page - 1) &lt;&#x3D; 100,000.
     * @return APIlistMyTradesRequest
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> List retrieved </td><td>  -  </td></tr>
     </table>
     */
    public APIlistMyTradesRequest listMyTrades() {
        return new APIlistMyTradesRequest();
    }

    /**
     * Build call for getSystemTime
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successfully retrieved </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getSystemTimeCall(final ApiCallback _callback) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/spot/time";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();
        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getSystemTimeValidateBeforeCall(final ApiCallback _callback) throws ApiException {
        okhttp3.Call localVarCall = getSystemTimeCall(_callback);
        return localVarCall;
    }

    /**
     * Get server current time
     * 
     * @return SystemTime
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successfully retrieved </td><td>  -  </td></tr>
     </table>
     */
    public SystemTime getSystemTime() throws ApiException {
        ApiResponse<SystemTime> localVarResp = getSystemTimeWithHttpInfo();
        return localVarResp.getData();
    }

    /**
     * Get server current time
     * 
     * @return ApiResponse&lt;SystemTime&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successfully retrieved </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<SystemTime> getSystemTimeWithHttpInfo() throws ApiException {
        okhttp3.Call localVarCall = getSystemTimeValidateBeforeCall(null);
        Type localVarReturnType = new TypeToken<SystemTime>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get server current time (asynchronously)
     * 
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successfully retrieved </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getSystemTimeAsync(final ApiCallback<SystemTime> _callback) throws ApiException {
        okhttp3.Call localVarCall = getSystemTimeValidateBeforeCall(_callback);
        Type localVarReturnType = new TypeToken<SystemTime>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    /**
     * Build call for countdownCancelAllSpot
     * @param countdownCancelAllSpotTask  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Set countdown successfully </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call countdownCancelAllSpotCall(CountdownCancelAllSpotTask countdownCancelAllSpotTask, final ApiCallback _callback) throws ApiException {
        Object localVarPostBody = countdownCancelAllSpotTask;

        // create path and map variables
        String localVarPath = "/spot/countdown_cancel_all";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();
        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] { "apiv4" };
        return localVarApiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call countdownCancelAllSpotValidateBeforeCall(CountdownCancelAllSpotTask countdownCancelAllSpotTask, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'countdownCancelAllSpotTask' is set
        if (countdownCancelAllSpotTask == null) {
            throw new ApiException("Missing the required parameter 'countdownCancelAllSpotTask' when calling countdownCancelAllSpot(Async)");
        }

        okhttp3.Call localVarCall = countdownCancelAllSpotCall(countdownCancelAllSpotTask, _callback);
        return localVarCall;
    }

    /**
     * Countdown cancel orders
     * When the timeout set by the user is reached, if there is no cancel or set a new countdown, the related pending orders will be automatically cancelled.  This endpoint can be called repeatedly to set a new countdown or cancel the countdown. For example, call this endpoint at 30s intervals, each countdown&#x60;timeout&#x60; is set to 30s. If this endpoint is not called again within 30 seconds, all pending orders on the specified &#x60;market&#x60; will be automatically cancelled, if no &#x60;market&#x60; is specified, all market pending orders will be cancelled. If the &#x60;timeout&#x60; is set to 0 within 30 seconds, the countdown timer will expire and the cacnel function will be cancelled.
     * @param countdownCancelAllSpotTask  (required)
     * @return TriggerTime
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Set countdown successfully </td><td>  -  </td></tr>
     </table>
     */
    public TriggerTime countdownCancelAllSpot(CountdownCancelAllSpotTask countdownCancelAllSpotTask) throws ApiException {
        ApiResponse<TriggerTime> localVarResp = countdownCancelAllSpotWithHttpInfo(countdownCancelAllSpotTask);
        return localVarResp.getData();
    }

    /**
     * Countdown cancel orders
     * When the timeout set by the user is reached, if there is no cancel or set a new countdown, the related pending orders will be automatically cancelled.  This endpoint can be called repeatedly to set a new countdown or cancel the countdown. For example, call this endpoint at 30s intervals, each countdown&#x60;timeout&#x60; is set to 30s. If this endpoint is not called again within 30 seconds, all pending orders on the specified &#x60;market&#x60; will be automatically cancelled, if no &#x60;market&#x60; is specified, all market pending orders will be cancelled. If the &#x60;timeout&#x60; is set to 0 within 30 seconds, the countdown timer will expire and the cacnel function will be cancelled.
     * @param countdownCancelAllSpotTask  (required)
     * @return ApiResponse&lt;TriggerTime&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Set countdown successfully </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<TriggerTime> countdownCancelAllSpotWithHttpInfo(CountdownCancelAllSpotTask countdownCancelAllSpotTask) throws ApiException {
        okhttp3.Call localVarCall = countdownCancelAllSpotValidateBeforeCall(countdownCancelAllSpotTask, null);
        Type localVarReturnType = new TypeToken<TriggerTime>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Countdown cancel orders (asynchronously)
     * When the timeout set by the user is reached, if there is no cancel or set a new countdown, the related pending orders will be automatically cancelled.  This endpoint can be called repeatedly to set a new countdown or cancel the countdown. For example, call this endpoint at 30s intervals, each countdown&#x60;timeout&#x60; is set to 30s. If this endpoint is not called again within 30 seconds, all pending orders on the specified &#x60;market&#x60; will be automatically cancelled, if no &#x60;market&#x60; is specified, all market pending orders will be cancelled. If the &#x60;timeout&#x60; is set to 0 within 30 seconds, the countdown timer will expire and the cacnel function will be cancelled.
     * @param countdownCancelAllSpotTask  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Set countdown successfully </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call countdownCancelAllSpotAsync(CountdownCancelAllSpotTask countdownCancelAllSpotTask, final ApiCallback<TriggerTime> _callback) throws ApiException {
        okhttp3.Call localVarCall = countdownCancelAllSpotValidateBeforeCall(countdownCancelAllSpotTask, _callback);
        Type localVarReturnType = new TypeToken<TriggerTime>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    /**
     * Build call for amendBatchOrders
     * @param batchAmendItem  (required)
     * @param xGateExptime Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Order modification executed successfully </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call amendBatchOrdersCall(List<BatchAmendItem> batchAmendItem, String xGateExptime, final ApiCallback _callback) throws ApiException {
        Object localVarPostBody = batchAmendItem;

        // create path and map variables
        String localVarPath = "/spot/amend_batch_orders";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        if (xGateExptime != null) {
            localVarHeaderParams.put("x-gate-exptime", localVarApiClient.parameterToString(xGateExptime));
        }

        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();
        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] { "apiv4" };
        return localVarApiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call amendBatchOrdersValidateBeforeCall(List<BatchAmendItem> batchAmendItem, String xGateExptime, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'batchAmendItem' is set
        if (batchAmendItem == null) {
            throw new ApiException("Missing the required parameter 'batchAmendItem' when calling amendBatchOrders(Async)");
        }

        okhttp3.Call localVarCall = amendBatchOrdersCall(batchAmendItem, xGateExptime, _callback);
        return localVarCall;
    }

    /**
     * Batch modification of orders
     * By default modify orders for spot, unified account and leverage account. Currently, only the price or quantity modification (choose one of two) Modify unfinished orders, up to 5 orders can be modified in batches at a time. The request parameters should be passed in array format. When the order modification fails during batch modification, the modification of the order will continue to be executed. After execution, the failure information of the corresponding order will be carried The order of calling the batch modification order is consistent with the order list The order of return content of batch modification orders is consistent with the order list
     * @param batchAmendItem  (required)
     * @param xGateExptime Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)
     * @return List&lt;BatchOrder&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Order modification executed successfully </td><td>  -  </td></tr>
     </table>
     */
    public List<BatchOrder> amendBatchOrders(List<BatchAmendItem> batchAmendItem, String xGateExptime) throws ApiException {
        ApiResponse<List<BatchOrder>> localVarResp = amendBatchOrdersWithHttpInfo(batchAmendItem, xGateExptime);
        return localVarResp.getData();
    }

    /**
     * Batch modification of orders
     * By default modify orders for spot, unified account and leverage account. Currently, only the price or quantity modification (choose one of two) Modify unfinished orders, up to 5 orders can be modified in batches at a time. The request parameters should be passed in array format. When the order modification fails during batch modification, the modification of the order will continue to be executed. After execution, the failure information of the corresponding order will be carried The order of calling the batch modification order is consistent with the order list The order of return content of batch modification orders is consistent with the order list
     * @param batchAmendItem  (required)
     * @param xGateExptime Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)
     * @return ApiResponse&lt;List&lt;BatchOrder&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Order modification executed successfully </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<List<BatchOrder>> amendBatchOrdersWithHttpInfo(List<BatchAmendItem> batchAmendItem, String xGateExptime) throws ApiException {
        okhttp3.Call localVarCall = amendBatchOrdersValidateBeforeCall(batchAmendItem, xGateExptime, null);
        Type localVarReturnType = new TypeToken<List<BatchOrder>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Batch modification of orders (asynchronously)
     * By default modify orders for spot, unified account and leverage account. Currently, only the price or quantity modification (choose one of two) Modify unfinished orders, up to 5 orders can be modified in batches at a time. The request parameters should be passed in array format. When the order modification fails during batch modification, the modification of the order will continue to be executed. After execution, the failure information of the corresponding order will be carried The order of calling the batch modification order is consistent with the order list The order of return content of batch modification orders is consistent with the order list
     * @param batchAmendItem  (required)
     * @param xGateExptime Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Order modification executed successfully </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call amendBatchOrdersAsync(List<BatchAmendItem> batchAmendItem, String xGateExptime, final ApiCallback<List<BatchOrder>> _callback) throws ApiException {
        okhttp3.Call localVarCall = amendBatchOrdersValidateBeforeCall(batchAmendItem, xGateExptime, _callback);
        Type localVarReturnType = new TypeToken<List<BatchOrder>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    private okhttp3.Call getSpotInsuranceHistoryCall(String business, String currency, Long from, Long to, Integer page, Integer limit, final ApiCallback _callback) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/spot/insurance_history";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        if (business != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("business", business));
        }

        if (currency != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("currency", currency));
        }

        if (page != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("page", page));
        }

        if (limit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("limit", limit));
        }

        if (from != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("from", from));
        }

        if (to != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("to", to));
        }

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();
        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getSpotInsuranceHistoryValidateBeforeCall(String business, String currency, Long from, Long to, Integer page, Integer limit, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'business' is set
        if (business == null) {
            throw new ApiException("Missing the required parameter 'business' when calling getSpotInsuranceHistory(Async)");
        }

        // verify the required parameter 'currency' is set
        if (currency == null) {
            throw new ApiException("Missing the required parameter 'currency' when calling getSpotInsuranceHistory(Async)");
        }

        // verify the required parameter 'from' is set
        if (from == null) {
            throw new ApiException("Missing the required parameter 'from' when calling getSpotInsuranceHistory(Async)");
        }

        // verify the required parameter 'to' is set
        if (to == null) {
            throw new ApiException("Missing the required parameter 'to' when calling getSpotInsuranceHistory(Async)");
        }

        okhttp3.Call localVarCall = getSpotInsuranceHistoryCall(business, currency, from, to, page, limit, _callback);
        return localVarCall;
    }


    private ApiResponse<List<SpotInsuranceHistory>> getSpotInsuranceHistoryWithHttpInfo(String business, String currency, Long from, Long to, Integer page, Integer limit) throws ApiException {
        okhttp3.Call localVarCall = getSpotInsuranceHistoryValidateBeforeCall(business, currency, from, to, page, limit, null);
        Type localVarReturnType = new TypeToken<List<SpotInsuranceHistory>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call getSpotInsuranceHistoryAsync(String business, String currency, Long from, Long to, Integer page, Integer limit, final ApiCallback<List<SpotInsuranceHistory>> _callback) throws ApiException {
        okhttp3.Call localVarCall = getSpotInsuranceHistoryValidateBeforeCall(business, currency, from, to, page, limit, _callback);
        Type localVarReturnType = new TypeToken<List<SpotInsuranceHistory>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class APIgetSpotInsuranceHistoryRequest {
        private final String business;
        private final String currency;
        private final Long from;
        private final Long to;
        private Integer page;
        private Integer limit;

        private APIgetSpotInsuranceHistoryRequest(String business, String currency, Long from, Long to) {
            this.business = business;
            this.currency = currency;
            this.from = from;
            this.to = to;
        }

        /**
         * Set page
         * @param page Page number (optional, default to 1)
         * @return APIgetSpotInsuranceHistoryRequest
         */
        public APIgetSpotInsuranceHistoryRequest page(Integer page) {
            this.page = page;
            return this;
        }

        /**
         * Set limit
         * @param limit The maximum number of items returned in the list, the default value is 30 (optional, default to 30)
         * @return APIgetSpotInsuranceHistoryRequest
         */
        public APIgetSpotInsuranceHistoryRequest limit(Integer limit) {
            this.limit = limit;
            return this;
        }

        /**
         * Build call for getSpotInsuranceHistory
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successfully retrieved </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return getSpotInsuranceHistoryCall(business, currency, from, to, page, limit, _callback);
        }

        /**
         * Execute getSpotInsuranceHistory request
         * @return List&lt;SpotInsuranceHistory&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successfully retrieved </td><td>  -  </td></tr>
         </table>
         */
        public List<SpotInsuranceHistory> execute() throws ApiException {
            ApiResponse<List<SpotInsuranceHistory>> localVarResp = getSpotInsuranceHistoryWithHttpInfo(business, currency, from, to, page, limit);
            return localVarResp.getData();
        }

        /**
         * Execute getSpotInsuranceHistory request with HTTP info returned
         * @return ApiResponse&lt;List&lt;SpotInsuranceHistory&gt;&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successfully retrieved </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<List<SpotInsuranceHistory>> executeWithHttpInfo() throws ApiException {
            return getSpotInsuranceHistoryWithHttpInfo(business, currency, from, to, page, limit);
        }

        /**
         * Execute getSpotInsuranceHistory request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successfully retrieved </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<List<SpotInsuranceHistory>> _callback) throws ApiException {
            return getSpotInsuranceHistoryAsync(business, currency, from, to, page, limit, _callback);
        }
    }

    /**
     * Query spot insurance fund historical data
     * 
     * @param business Leverage business, margin - position by position; unified - unified account (required)
     * @param currency Currency (required)
     * @param from Start timestamp, seconds (required)
     * @param to End timestamp, in seconds (required)
     * @return APIgetSpotInsuranceHistoryRequest
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successfully retrieved </td><td>  -  </td></tr>
     </table>
     */
    public APIgetSpotInsuranceHistoryRequest getSpotInsuranceHistory(String business, String currency, Long from, Long to) {
        return new APIgetSpotInsuranceHistoryRequest(business, currency, from, to);
    }

    private okhttp3.Call listSpotPriceTriggeredOrdersCall(String status, String market, String account, Integer limit, Integer offset, final ApiCallback _callback) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/spot/price_orders";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        if (status != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("status", status));
        }

        if (market != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("market", market));
        }

        if (account != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("account", account));
        }

        if (limit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("limit", limit));
        }

        if (offset != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("offset", offset));
        }

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();
        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] { "apiv4" };
        return localVarApiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call listSpotPriceTriggeredOrdersValidateBeforeCall(String status, String market, String account, Integer limit, Integer offset, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'status' is set
        if (status == null) {
            throw new ApiException("Missing the required parameter 'status' when calling listSpotPriceTriggeredOrders(Async)");
        }

        okhttp3.Call localVarCall = listSpotPriceTriggeredOrdersCall(status, market, account, limit, offset, _callback);
        return localVarCall;
    }


    private ApiResponse<List<SpotPriceTriggeredOrder>> listSpotPriceTriggeredOrdersWithHttpInfo(String status, String market, String account, Integer limit, Integer offset) throws ApiException {
        okhttp3.Call localVarCall = listSpotPriceTriggeredOrdersValidateBeforeCall(status, market, account, limit, offset, null);
        Type localVarReturnType = new TypeToken<List<SpotPriceTriggeredOrder>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call listSpotPriceTriggeredOrdersAsync(String status, String market, String account, Integer limit, Integer offset, final ApiCallback<List<SpotPriceTriggeredOrder>> _callback) throws ApiException {
        okhttp3.Call localVarCall = listSpotPriceTriggeredOrdersValidateBeforeCall(status, market, account, limit, offset, _callback);
        Type localVarReturnType = new TypeToken<List<SpotPriceTriggeredOrder>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class APIlistSpotPriceTriggeredOrdersRequest {
        private final String status;
        private String market;
        private String account;
        private Integer limit;
        private Integer offset;

        private APIlistSpotPriceTriggeredOrdersRequest(String status) {
            this.status = status;
        }

        /**
         * Set market
         * @param market Currency pair (optional)
         * @return APIlistSpotPriceTriggeredOrdersRequest
         */
        public APIlistSpotPriceTriggeredOrdersRequest market(String market) {
            this.market = market;
            return this;
        }

        /**
         * Set account
         * @param account Trading account type.  Portfolio margin account must set to &#x60;unified&#x60; (optional)
         * @return APIlistSpotPriceTriggeredOrdersRequest
         */
        public APIlistSpotPriceTriggeredOrdersRequest account(String account) {
            this.account = account;
            return this;
        }

        /**
         * Set limit
         * @param limit Maximum number of records to be returned in a single list (optional, default to 100)
         * @return APIlistSpotPriceTriggeredOrdersRequest
         */
        public APIlistSpotPriceTriggeredOrdersRequest limit(Integer limit) {
            this.limit = limit;
            return this;
        }

        /**
         * Set offset
         * @param offset List offset, starting from 0 (optional, default to 0)
         * @return APIlistSpotPriceTriggeredOrdersRequest
         */
        public APIlistSpotPriceTriggeredOrdersRequest offset(Integer offset) {
            this.offset = offset;
            return this;
        }

        /**
         * Build call for listSpotPriceTriggeredOrders
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> List retrieved </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return listSpotPriceTriggeredOrdersCall(status, market, account, limit, offset, _callback);
        }

        /**
         * Execute listSpotPriceTriggeredOrders request
         * @return List&lt;SpotPriceTriggeredOrder&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> List retrieved </td><td>  -  </td></tr>
         </table>
         */
        public List<SpotPriceTriggeredOrder> execute() throws ApiException {
            ApiResponse<List<SpotPriceTriggeredOrder>> localVarResp = listSpotPriceTriggeredOrdersWithHttpInfo(status, market, account, limit, offset);
            return localVarResp.getData();
        }

        /**
         * Execute listSpotPriceTriggeredOrders request with HTTP info returned
         * @return ApiResponse&lt;List&lt;SpotPriceTriggeredOrder&gt;&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> List retrieved </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<List<SpotPriceTriggeredOrder>> executeWithHttpInfo() throws ApiException {
            return listSpotPriceTriggeredOrdersWithHttpInfo(status, market, account, limit, offset);
        }

        /**
         * Execute listSpotPriceTriggeredOrders request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> List retrieved </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<List<SpotPriceTriggeredOrder>> _callback) throws ApiException {
            return listSpotPriceTriggeredOrdersAsync(status, market, account, limit, offset, _callback);
        }
    }

    /**
     * Retrieve running auto order list
     * 
     * @param status Only list the orders with this status (required)
     * @return APIlistSpotPriceTriggeredOrdersRequest
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> List retrieved </td><td>  -  </td></tr>
     </table>
     */
    public APIlistSpotPriceTriggeredOrdersRequest listSpotPriceTriggeredOrders(String status) {
        return new APIlistSpotPriceTriggeredOrdersRequest(status);
    }

    /**
     * Build call for createSpotPriceTriggeredOrder
     * @param spotPriceTriggeredOrder  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> Order created </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call createSpotPriceTriggeredOrderCall(SpotPriceTriggeredOrder spotPriceTriggeredOrder, final ApiCallback _callback) throws ApiException {
        Object localVarPostBody = spotPriceTriggeredOrder;

        // create path and map variables
        String localVarPath = "/spot/price_orders";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();
        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] { "apiv4" };
        return localVarApiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call createSpotPriceTriggeredOrderValidateBeforeCall(SpotPriceTriggeredOrder spotPriceTriggeredOrder, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'spotPriceTriggeredOrder' is set
        if (spotPriceTriggeredOrder == null) {
            throw new ApiException("Missing the required parameter 'spotPriceTriggeredOrder' when calling createSpotPriceTriggeredOrder(Async)");
        }

        okhttp3.Call localVarCall = createSpotPriceTriggeredOrderCall(spotPriceTriggeredOrder, _callback);
        return localVarCall;
    }

    /**
     * Create a price-triggered order
     * 
     * @param spotPriceTriggeredOrder  (required)
     * @return TriggerOrderResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> Order created </td><td>  -  </td></tr>
     </table>
     */
    public TriggerOrderResponse createSpotPriceTriggeredOrder(SpotPriceTriggeredOrder spotPriceTriggeredOrder) throws ApiException {
        ApiResponse<TriggerOrderResponse> localVarResp = createSpotPriceTriggeredOrderWithHttpInfo(spotPriceTriggeredOrder);
        return localVarResp.getData();
    }

    /**
     * Create a price-triggered order
     * 
     * @param spotPriceTriggeredOrder  (required)
     * @return ApiResponse&lt;TriggerOrderResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> Order created </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<TriggerOrderResponse> createSpotPriceTriggeredOrderWithHttpInfo(SpotPriceTriggeredOrder spotPriceTriggeredOrder) throws ApiException {
        okhttp3.Call localVarCall = createSpotPriceTriggeredOrderValidateBeforeCall(spotPriceTriggeredOrder, null);
        Type localVarReturnType = new TypeToken<TriggerOrderResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Create a price-triggered order (asynchronously)
     * 
     * @param spotPriceTriggeredOrder  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> Order created </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call createSpotPriceTriggeredOrderAsync(SpotPriceTriggeredOrder spotPriceTriggeredOrder, final ApiCallback<TriggerOrderResponse> _callback) throws ApiException {
        okhttp3.Call localVarCall = createSpotPriceTriggeredOrderValidateBeforeCall(spotPriceTriggeredOrder, _callback);
        Type localVarReturnType = new TypeToken<TriggerOrderResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    /**
     * Build call for cancelSpotPriceTriggeredOrderList
     * @param market Currency pair (optional)
     * @param account Trading account type.  Portfolio margin account must set to &#x60;unified&#x60; (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Batch cancellation request accepted. Query order status by listing orders </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call cancelSpotPriceTriggeredOrderListCall(String market, String account, final ApiCallback _callback) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/spot/price_orders";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        if (market != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("market", market));
        }

        if (account != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("account", account));
        }

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();
        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] { "apiv4" };
        return localVarApiClient.buildCall(localVarPath, "DELETE", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call cancelSpotPriceTriggeredOrderListValidateBeforeCall(String market, String account, final ApiCallback _callback) throws ApiException {
        okhttp3.Call localVarCall = cancelSpotPriceTriggeredOrderListCall(market, account, _callback);
        return localVarCall;
    }

    /**
     * Cancel All Price-triggered Orders
     * 
     * @param market Currency pair (optional)
     * @param account Trading account type.  Portfolio margin account must set to &#x60;unified&#x60; (optional)
     * @return List&lt;SpotPriceTriggeredOrder&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Batch cancellation request accepted. Query order status by listing orders </td><td>  -  </td></tr>
     </table>
     */
    public List<SpotPriceTriggeredOrder> cancelSpotPriceTriggeredOrderList(String market, String account) throws ApiException {
        ApiResponse<List<SpotPriceTriggeredOrder>> localVarResp = cancelSpotPriceTriggeredOrderListWithHttpInfo(market, account);
        return localVarResp.getData();
    }

    /**
     * Cancel All Price-triggered Orders
     * 
     * @param market Currency pair (optional)
     * @param account Trading account type.  Portfolio margin account must set to &#x60;unified&#x60; (optional)
     * @return ApiResponse&lt;List&lt;SpotPriceTriggeredOrder&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Batch cancellation request accepted. Query order status by listing orders </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<List<SpotPriceTriggeredOrder>> cancelSpotPriceTriggeredOrderListWithHttpInfo(String market, String account) throws ApiException {
        okhttp3.Call localVarCall = cancelSpotPriceTriggeredOrderListValidateBeforeCall(market, account, null);
        Type localVarReturnType = new TypeToken<List<SpotPriceTriggeredOrder>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Cancel All Price-triggered Orders (asynchronously)
     * 
     * @param market Currency pair (optional)
     * @param account Trading account type.  Portfolio margin account must set to &#x60;unified&#x60; (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Batch cancellation request accepted. Query order status by listing orders </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call cancelSpotPriceTriggeredOrderListAsync(String market, String account, final ApiCallback<List<SpotPriceTriggeredOrder>> _callback) throws ApiException {
        okhttp3.Call localVarCall = cancelSpotPriceTriggeredOrderListValidateBeforeCall(market, account, _callback);
        Type localVarReturnType = new TypeToken<List<SpotPriceTriggeredOrder>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    /**
     * Build call for getSpotPriceTriggeredOrder
     * @param orderId Retrieve the data of the order with the specified ID (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Auto order detail </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getSpotPriceTriggeredOrderCall(String orderId, final ApiCallback _callback) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/spot/price_orders/{order_id}"
            .replaceAll("\\{" + "order_id" + "\\}", localVarApiClient.escapeString(orderId));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();
        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] { "apiv4" };
        return localVarApiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getSpotPriceTriggeredOrderValidateBeforeCall(String orderId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'orderId' is set
        if (orderId == null) {
            throw new ApiException("Missing the required parameter 'orderId' when calling getSpotPriceTriggeredOrder(Async)");
        }

        okhttp3.Call localVarCall = getSpotPriceTriggeredOrderCall(orderId, _callback);
        return localVarCall;
    }

    /**
     * Get a price-triggered order
     * 
     * @param orderId Retrieve the data of the order with the specified ID (required)
     * @return SpotPriceTriggeredOrder
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Auto order detail </td><td>  -  </td></tr>
     </table>
     */
    public SpotPriceTriggeredOrder getSpotPriceTriggeredOrder(String orderId) throws ApiException {
        ApiResponse<SpotPriceTriggeredOrder> localVarResp = getSpotPriceTriggeredOrderWithHttpInfo(orderId);
        return localVarResp.getData();
    }

    /**
     * Get a price-triggered order
     * 
     * @param orderId Retrieve the data of the order with the specified ID (required)
     * @return ApiResponse&lt;SpotPriceTriggeredOrder&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Auto order detail </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<SpotPriceTriggeredOrder> getSpotPriceTriggeredOrderWithHttpInfo(String orderId) throws ApiException {
        okhttp3.Call localVarCall = getSpotPriceTriggeredOrderValidateBeforeCall(orderId, null);
        Type localVarReturnType = new TypeToken<SpotPriceTriggeredOrder>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get a price-triggered order (asynchronously)
     * 
     * @param orderId Retrieve the data of the order with the specified ID (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Auto order detail </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getSpotPriceTriggeredOrderAsync(String orderId, final ApiCallback<SpotPriceTriggeredOrder> _callback) throws ApiException {
        okhttp3.Call localVarCall = getSpotPriceTriggeredOrderValidateBeforeCall(orderId, _callback);
        Type localVarReturnType = new TypeToken<SpotPriceTriggeredOrder>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    /**
     * Build call for cancelSpotPriceTriggeredOrder
     * @param orderId Retrieve the data of the order with the specified ID (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Auto order detail </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call cancelSpotPriceTriggeredOrderCall(String orderId, final ApiCallback _callback) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/spot/price_orders/{order_id}"
            .replaceAll("\\{" + "order_id" + "\\}", localVarApiClient.escapeString(orderId));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();
        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] { "apiv4" };
        return localVarApiClient.buildCall(localVarPath, "DELETE", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call cancelSpotPriceTriggeredOrderValidateBeforeCall(String orderId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'orderId' is set
        if (orderId == null) {
            throw new ApiException("Missing the required parameter 'orderId' when calling cancelSpotPriceTriggeredOrder(Async)");
        }

        okhttp3.Call localVarCall = cancelSpotPriceTriggeredOrderCall(orderId, _callback);
        return localVarCall;
    }

    /**
     * cancel a price-triggered order
     * 
     * @param orderId Retrieve the data of the order with the specified ID (required)
     * @return SpotPriceTriggeredOrder
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Auto order detail </td><td>  -  </td></tr>
     </table>
     */
    public SpotPriceTriggeredOrder cancelSpotPriceTriggeredOrder(String orderId) throws ApiException {
        ApiResponse<SpotPriceTriggeredOrder> localVarResp = cancelSpotPriceTriggeredOrderWithHttpInfo(orderId);
        return localVarResp.getData();
    }

    /**
     * cancel a price-triggered order
     * 
     * @param orderId Retrieve the data of the order with the specified ID (required)
     * @return ApiResponse&lt;SpotPriceTriggeredOrder&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Auto order detail </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<SpotPriceTriggeredOrder> cancelSpotPriceTriggeredOrderWithHttpInfo(String orderId) throws ApiException {
        okhttp3.Call localVarCall = cancelSpotPriceTriggeredOrderValidateBeforeCall(orderId, null);
        Type localVarReturnType = new TypeToken<SpotPriceTriggeredOrder>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * cancel a price-triggered order (asynchronously)
     * 
     * @param orderId Retrieve the data of the order with the specified ID (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Auto order detail </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call cancelSpotPriceTriggeredOrderAsync(String orderId, final ApiCallback<SpotPriceTriggeredOrder> _callback) throws ApiException {
        okhttp3.Call localVarCall = cancelSpotPriceTriggeredOrderValidateBeforeCall(orderId, _callback);
        Type localVarReturnType = new TypeToken<SpotPriceTriggeredOrder>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

}
